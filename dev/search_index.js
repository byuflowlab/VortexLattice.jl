var documenterSearchIndex = {"docs":
[{"location":"guide/#Guide","page":"Getting Started","title":"Guide","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"This guide demonstrates the basic steady analysis capabilities of VortexLattice. See the examples for more advanced uses of VortexLattice, including unsteady simulations.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We start by loading the package.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"using VortexLattice\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Then we need to create our geometry.  While VortexLattice can handle multiple lifting surfaces, for this guide we will be analyzing a wing with the following geometric properties.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"xle = [0.0, 0.4] # leading edge x-position\nyle = [0.0, 7.5] # leading edge y-position\nzle = [0.0, 0.0] # leading edge z-position\nchord = [2.2, 1.8] # chord length\ntheta = [2.0*pi/180, 2.0*pi/180] # twist (in radians)\nphi = [0.0, 0.0] # section rotation about the x-axis\nfc = fill((xc) -> 0, 2) # camberline function for each section (y/c = f(x/c))\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Note that we are only defining half the wing since the wing is symmetric about the X-Z plane.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We also need to define the number of panels and the discretization scheme in the spanwise and chordwise directions.  There are currently three discretization scheme options: Uniform(), Sine(), and Cosine().  To maximize the accuracy of our analysis we would like to use cosine spacing in the spanwise direction.  To do this, we need to use sine spacing on the right half of the wing (since once reflected across the y-z plane, sine spacing become cosine spacing).  ","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"ns = 12 # number of spanwise panels\nnc = 6  # number of chordwise panels\nspacing_s = Sine() # spanwise discretization scheme\nspacing_c = Uniform() # chordwise discretization scheme\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We generate our lifting surface using wing_to_surface_panels.  We use the keyword argument mirror to mirror our geometry across the X-Y plane.  A grid with the panel corners and a matrix of vortex lattice panels representing the surface of the wing is returned from this function.  Only the latter is needed for the analysis. The former is provided primarily for the user's convenience, but may also used to find lifting line properties (as will be shown later in this guide).","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"grid, surface = wing_to_surface_panels(xle, yle, zle, chord, theta, phi, ns, nc;\nfc = fc, spacing_s=spacing_s, spacing_c=spacing_c, mirror=true)\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We could have also generated our lifting surface from a pre-existing grid using grid_to_surface_panels.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The last step in defining our geometry is to combine all surfaces in a single vector.  Since we only have one surface, we create a vector with a single element.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"surfaces = [surface]\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Now that we have generated our geometry we need to define our reference parameters and freestream properties. We use the following reference parameters","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Sref = 30.0 # reference area\ncref = 2.0  # reference chord\nbref = 15.0 # reference span\nrref = [0.50, 0.0, 0.0] # reference location for rotations/moments (typically the c.g.)\nVinf = 1.0 # reference velocity (magnitude)\nref = Reference(Sref, cref, bref, rref, Vinf)\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We use the following freestream properties.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"alpha = 1.0*pi/180 # angle of attack\nbeta = 0.0 # sideslip angle\nOmega = [0.0, 0.0, 0.0] # rotational velocity around the reference location\nfs = Freestream(Vinf, alpha, beta, Omega)\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Since the flow conditions are symmetric, we could have modeled one half of our wing and used symmetry to model the other half.  This, however, would give incorrect results for the lateral stability derivatives so we have instead mirrored our geometry across the X-Z plane.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"symmetric = false\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We are now ready to perform a steady state analysis. We do so by calling the steady_analysis function. This function:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Finds the circulation distribution for a given set of panels and flow conditions\nPerforms a near-field analysis to find the forces on each panel, unless otherwise specified through the keyword argument near_field_analysis\nDetermines the derivatives of the near-field analysis forces with respect to the freestream variables, unless otherwise specified through the keyword argument derivatives","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"system = steady_analysis(surfaces, ref, fs; symmetric)\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The result of our analysis is an object of type system which holds the system state.  Note that the keyword argument symmetric is not strictly necessary, since by default it is set to false for each surface.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Once we have performed our steady state analysis (and associated near field analysis) we can extract the body force/moment coefficients using the function body_forces. These forces are returned in the reference frame specified by the keyword argument frame, which defaults to the body reference frame.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Note that a near field analysis must have been performed on system for this function to return sensible results (which is the default behavior when running an analysis).","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"CF, CM = body_forces(system; frame=Wind())\n\n# extract aerodynamic forces\nCD, CY, CL = CF\nCl, Cm, Cn = CM\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Numerical noise often corrupts drag estimates from near-field analyses, therefore, it is often more accurate to compute drag in the farfield on the Trefftz plane.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"CDiff = far_field_drag(system)\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Sectional coefficients may be calculated using the lifting_line_properties function.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# combine all grid representations of surfaces into a single vector\ngrids = [grid]\n\n# calculate lifting line geometry\nr, c = lifting_line_geometry(grids)\n\n# calculate lifting line coefficients\ncf, cm = lifting_line_coefficients(system, r, c; frame=Body())\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"These coefficients are defined as c_f = fracFq_infty c and c_m = fracMq_infty c^2, respectively, where F is the force per unit length along the lifting line, M is the moment per unit length along the lifting line, q_infty is the freestream dynamic pressure, and c is the local chord length.   By default, these coefficients are defined in the body frame, but may be returned in the stability or wind frame by using the frame keyword argument.  Note that further manipulations upon these coefficients may be required to calculate local aerodynamic coefficients since 1) the local frame of reference is not necessarily equivalent to the global frame of reference and 2) the quantities used to normalize a given local aerodynamic coefficient may vary from those used in this package.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We can also extract the body and/or stability derivatives for the aircraft easily using the functions body_derivatives and/or stability_derivatives.  ","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Once again, note that the derivatives of the near-field analysis forces with respect to the freestream variables must have been previously calculated (which is the default behavior when running an analysis) for these functions to yield sensible results.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"dCFb, dCMb = body_derivatives(system)\n\n# traditional names for each body derivative\nCXu, CYu, CZu = dCFb.u\nCXv, CYv, CZv = dCFb.v\nCXw, CYw, CZw = dCFb.w\nCXp, CYp, CZp = dCFb.p\nCXq, CYq, CZq = dCFb.q\nCXr, CYr, CZr = dCFb.r\nClu, Cmu, Cnu = dCMb.u\nClv, Cmv, Cnv = dCMb.v\nClw, Cmw, Cnw = dCMb.w\nClp, Cmp, Cnp = dCMb.p\nClq, Cmq, Cnq = dCMb.q\nClr, Cmr, Cnr = dCMb.r\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"dCFs, dCMs = stability_derivatives(system)\n\n# traditional names for each stability derivative\nCDa, CYa, CLa = dCFs.alpha\nCla, Cma, Cna = dCMs.alpha\nCDb, CYb, CLb = dCFs.beta\nClb, Cmb, Cnb = dCMs.beta\nCDp, CYp, CLp = dCFs.p\nClp, Cmp, Cnp = dCMs.p\nCDq, CYq, CLq = dCFs.q\nClq, Cmq, Cnq = dCMs.q\nCDr, CYr, CLr = dCFs.r\nClr, Cmr, Cnr = dCMs.r\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Visualizing the geometry (and results) may be done in Paraview after writing the associated visualization files using write_vtk.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"properties = get_surface_properties(system)\n\nwrite_vtk(\"simplewing\", surfaces, properties)","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"For visualization purposes, positive circulation is defined in the +i and +j directions.","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"See the following references:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[1] Drela, M. Flight Vehicle Aerodynamics. MIT Press, 2014.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[2] Katz, J., and Plotkin A. Low-Speed Aerodynamics. Cambridge University Press, 2001.","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages = [\"library.md\"]\nDepth = 3","category":"page"},{"location":"library/#Public-API","page":"Library","title":"Public API","text":"","category":"section"},{"location":"library/#Generating-Lifting-Surfaces","page":"Library","title":"Generating Lifting Surfaces","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"AbstractSpacing\nUniform\nSine\nCosine\nSurfacePanel\nSurfacePanel()\nWakePanel\nWakePanel()\ngrid_to_surface_panels\nwing_to_surface_panels\nlifting_line_geometry\nlifting_line_geometry!\nread_degengeom\nimport_vsp\nset_normal\ntranslate\ntranslate!\nrotate\nrotate!\nreflect(surface::AbstractMatrix)","category":"page"},{"location":"library/#VortexLattice.AbstractSpacing","page":"Library","title":"VortexLattice.AbstractSpacing","text":"AbstractSpacing\n\nSpacing discretization scheme supertype\n\n\n\n\n\n","category":"type"},{"location":"library/#VortexLattice.Uniform","page":"Library","title":"VortexLattice.Uniform","text":"Uniform()\n\nUniform discretization scheme.\n\n\n\n\n\n","category":"type"},{"location":"library/#VortexLattice.Sine","page":"Library","title":"VortexLattice.Sine","text":"Sine()\n\nSine-spaced discretization scheme.  Using sine-spacing on the right half of a wing effectively results in cosine spacing once symmetry is applied.\n\n\n\n\n\n","category":"type"},{"location":"library/#VortexLattice.Cosine","page":"Library","title":"VortexLattice.Cosine","text":"Cosine()\n\nCosine-spaced discretization scheme.  This is typically one of the most accurate spacing schemes for spanwise spacing.\n\n\n\n\n\n","category":"type"},{"location":"library/#VortexLattice.SurfacePanel","page":"Library","title":"VortexLattice.SurfacePanel","text":"SurfacePanel{TF}\n\nLifting surface panel with attached vortex ring\n\nFields\n\nrtl: position of the left side of the top bound vortex\nrtc: position of the center of the top bound vortex\nrtr: position of the right side of the top bound vortex\nrbl: position of the left side of the bottom bound vortex\nrbc: position of the center of the bottom bound vortex\nrbr: position of the right side of the bottom bound vortex\nrcp: position of the panel control point\nncp: normal vector at the panel control point\ncore_size: finite core size (for use when the finite core smoothing model is enabled)\nchord: panel chord length (for determining unsteady forces)\n\n\n\n\n\n","category":"type"},{"location":"library/#VortexLattice.SurfacePanel-Tuple{}","page":"Library","title":"VortexLattice.SurfacePanel","text":"SurfacePanel(rtl, rtr, rbl, rbr, rcp, ncp, core_size, chord; kwargs...)\n\nConstruct and return a vortex ring panel.\n\nArguments\n\nrtl: position of the left side of the top bound vortex\nrtr: position of the right side of the top bound vortex\nrbl: position of the left side of the bottom bound vortex\nrbr: position of the right side of the bottom bound vortex\nrcp: position of the panel control point\nncp: normal vector at the panel control point\ncore_size: finite core size (for use when the finite core smoothing model is enabled)\nchord: panel chord length (for determining unsteady forces)\n\nKeyword Arguments\n\nrtc: position of the center of the top bound vortex, defaults to (rtl+rtr)/2\nrbc: position of the center of the bottom bound vortex, defaults to (rbl+rbr)/2\n\n\n\n\n\n","category":"method"},{"location":"library/#VortexLattice.WakePanel","page":"Library","title":"VortexLattice.WakePanel","text":"WakePanel{TF}\n\nSurfacePanel used for modeling wakes.\n\nFields\n\nrtl: position of the left side of the top bound vortex\nrtr: position of the right side of the top bound vortex\nrbl: position of the left side of the bottom bound vortex\nrbr: position of the right side of the bottom bound vortex\ncore_size: finite core size (for use when the finite core smoothing model is enabled)\ngamma: circulation strength of the panel\n\n\n\n\n\n","category":"type"},{"location":"library/#VortexLattice.WakePanel-Tuple{}","page":"Library","title":"VortexLattice.WakePanel","text":"WakePanel(rtl, rtr, rbl, rbr, core_size, gamma)\n\nConstruct and return a wake panel.\n\nArguments\n\nrtl: position of the left side of the top bound vortex\nrtr: position of the right side of the top bound vortex\nrbl: position of the left side of the bottom bound vortex\nrbr: position of the right side of the bottom bound vortex\ncore_size: finite core size\ngamma: circulation strength of the panel\n\n\n\n\n\n","category":"method"},{"location":"library/#VortexLattice.grid_to_surface_panels","page":"Library","title":"VortexLattice.grid_to_surface_panels","text":"grid_to_surface_panels(xyz; mirror = false, fcore = (c, Δs) -> 1e-3)\n\nConstruct a set of panels with associated vortex rings given a potentially curved lifting surface defined by a grid with dimensions (3, i, j) where i corresponds to the chordwise direction (ordered from leading edge to trailing edge) and j corresponds to the spanwise direction (ordered from left to right).  The leading edge of each ring vortex will be placed at the 1/4 chord and the control point will be placed at the 3/4 chord of each panel.\n\nReturn a grid with dimensions (3, i, j) containing the panel corners and a matrix with dimensions (i, j) containing the generated panels.\n\nKeyword Arguments\n\nmirror:  mirror the geometry across the X-Z plane? defaults to false.\nfcore: function for setting the finite core size based on the chord length      (in the x-direction) and/or the panel width (in the y/z directions).      Defaults to (c, Δs) -> 1e-3\n\n\n\n\n\ngrid_to_surface_panels(xyz, ns, nc;\n    mirror = false,\n    fcore = (c, Δs) -> 1e-3,\n    spacing_s = Cosine(),\n    spacing_c = Uniform(),\n    interp_s = (x, y, xpt) -> FLOWMath.linear(x, y, xpt),\n    interp_c = (x, y, xpt) -> FLOWMath.linear(x, y, xpt))\n\nDiscretize a potentially curved lifting surface defined by a grid with dimensions (3, i, j) where i corresponds to the chordwise direction (ordered from leading edge to trailing edge) and j corresponds to the spanwise direction (ordered from left to right) into ns spanwise and nc chordwise panels with associated vortex rings according to the spanwise discretization scheme spacing_s and chordwise discretization scheme spacing_c.  The bound vortex will be placed at the 1/4 chord and the control point will be placed at the 3/4 chord of each panel.\n\nReturn a grid with dimensions (3, i, j) containing the interpolated panel corners and a matrix with dimensions (i, j) containing the generated panels.\n\nArguments\n\nxyz: grid of dimensions (3, i, j) where where i corresponds to the  chordwise direction and j corresponds to the spanwise direction.\nns: number of spanwise panels\nnc: number of chordwise panels\n\nKeyword Arguments\n\nmirror:  mirror the geometry across the X-Z plane? defaults to false.\nfcore: function for setting the finite core size based on the chord length      (in the x-direction) and/or the panel width (in the y/z directions).      Defaults to (c, Δs) -> 1e-3\nspacing_s: spanwise discretization scheme, defaults to Cosine()\nspacing_c: chordwise discretization scheme, defaults to Uniform()\ninterp_s: spanwise interpolation function, defaults to linear interpolation\ninterp_c: chordwise interpolation function, defaults to linear interpolation\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.wing_to_surface_panels","page":"Library","title":"VortexLattice.wing_to_surface_panels","text":"wing_to_surface_panels(xle, yle, zle, chord, theta, phi, ns, nc;\n    fc = fill(x -> 0, length(xle)),\n    mirror = false,\n    fcore = (c, Δs) -> 1e-3,\n    spacing_s = Cosine(),\n    spacing_c = Uniform(),\n    interp_s = (x, y, xpt) -> FLOWMath.linear(x, y, xpt))\n\nDiscretize a wing into ns spanwise and nc chordwise panels with associated vortex rings according to the spanwise discretization scheme spacing_s and chordwise discretization scheme spacing_c.\n\nReturn a grid with dimensions (3, i, j) containing the panel corners and a matrix with dimensions (i, j) containing the generated panels.\n\nArguments\n\nxle: leading edge x-coordinate of each airfoil section\nyle: leading edge y-coordinate of each airfoil section\nzle: leading edge z-coordinate of each airfoil section\nchord: chord length of each airfoil section\ntheta: twist of each airfoil section\nphi: dihedral angle of each airfoil section, defined by a right hand rotation about the x-axis\nns: number of spanwise panels\nnc: number of chordwise panels\nfc: (optional) camber line function y=f(x) of each airfoil section\n'reference_line': 2D array, each row is the x, y coordinate of the reference point of the airfoil.      This allows xle, yle, and zle to be defined about points that are not the leading edge\nmirror:  mirror the geometry across the X-Z plane?, defaults to false\nfcore: function for setting the finite core size based on the chord length      (in the x-direction) and/or the panel width (in the y/z directions).      Defaults to (c, Δs) -> 1e-3\nspacing_s: spanwise discretization scheme, defaults to Cosine()\nspacing_c: chordwise discretization scheme, defaults to Uniform()\ninterp_s: interpolation function between spanwise stations, defaults to linear interpolation\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.lifting_line_geometry","page":"Library","title":"VortexLattice.lifting_line_geometry","text":"lifting_line_geometry(grids, xc=0.25)\n\nConstruct a lifting line representation of the surfaces in grids at the normalized chordwise location xc.  Return the lifting line coordinates and chord lengths.\n\nArguments\n\ngrids: Vector with length equal to the number of surfaces.  Each element of  the vector is a grid with shape (3, nc, ns) which defines the discretization  of a surface into panels. nc is the number of chordwise panels and ns is  the number of spanwise panels.\nxc: Normalized chordwise location of the lifting line from the leading edge.  Defaults to the quarter chord\n\nReturn Arguments:\n\nr: Vector with length equal to the number of surfaces, with each element  being a matrix with size (3, ns+1) which contains the x, y, and z coordinates  of the resulting lifting line coordinates\nc: Vector with length equal to the number of surfaces, with each element  being a vector of length ns+1 which contains the chord lengths at each  lifting line coordinate.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.lifting_line_geometry!","page":"Library","title":"VortexLattice.lifting_line_geometry!","text":"lifting_line_geometry!(r, c, grids, xc=0.25)\n\nIn-place version of lifting_line_geometry\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.read_degengeom","page":"Library","title":"VortexLattice.read_degengeom","text":"`read_degengeom(filename::String)`\n\nRead all geometry components from a DegenGeom file written out by OpenVSP\n\nArguments\n\nfilename::String: DegenGeom filename\n\nReturns\n\ncomp: Vector of vsp.VSPComponent objects\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.import_vsp","page":"Library","title":"VortexLattice.import_vsp","text":"`import_vsp(comp::vsp.VSPComponent; geomType::String=\"\", optargs...)\n\nImports properties from OpenVSP component to VortexLattice objects. Importing prop and duct geometries are under development.\n\nArguments\n\ncomp::VSPGeom.VSPComponent: Single VSPGeom.VSPComponent object\ngeomType::String : Geometry type may be one of - wing, fuselage, prop, duct\noptargs : Optional arguments that are passed into gridtosurface_panels() called inside\n\nReturns\n\ngrid: Array with dimensions (3, i, j) containing the panel corners\nsurface: Array with dimensions (i, j) containing generated panels\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.set_normal","page":"Library","title":"VortexLattice.set_normal","text":"set_normal(panel::SurfacePanel, ncp)\n\nReturn a copy of panel with the new normal vector ncp\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.translate","page":"Library","title":"VortexLattice.translate","text":"translate(panel::SurfacePanel, r)\n\nReturn a copy of panel translated the distance specified by vector r\n\n\n\n\n\ntranslate(surface, r)\n\nReturn a copy of the panels in surface translated the distance specified by vector r\n\n\n\n\n\ntranslate(surfaces, r)\n\nReturn a copy of the surfaces in surfaces translated the distance specified by vector r\n\n\n\n\n\ntranslate(grid, r)\n\nReturn a copy of the grid points in grid translated the distance specified by vector r\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.translate!","page":"Library","title":"VortexLattice.translate!","text":"translate!(surface, r)\n\nTranslate the panels in surface the distance specified by vector r\n\n\n\n\n\ntranslate!(surfaces, r)\n\nTranslate the surfaces in surfaces the distance specified by vector r\n\n\n\n\n\ntranslate!(grid, r)\n\nTranslate the grid points in grid the distance specified by vector r\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.rotate","page":"Library","title":"VortexLattice.rotate","text":"rotate(panel::SurfacePanel, R, r = [0,0,0])\n\nReturn a copy of panel rotated about point r using the rotation matrix R\n\n\n\n\n\nrotate(surface, R, r = [0,0,0])\n\nReturn a copy of the panels in surface rotated about point r using the rotation matrix R\n\n\n\n\n\nrotate(surfaces, R, r = [0,0,0])\n\nReturn a copy of the surfaces in surfaces rotated about point r using the rotation matrix R\n\n\n\n\n\nrotate(grid, R, r = [0,0,0])\n\nReturn a copy of the grid points in grid rotated about point r using the rotation matrix R\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.rotate!","page":"Library","title":"VortexLattice.rotate!","text":"rotate!(surface, R, r = [0,0,0])\n\nRotate the panels in surface about point r using the rotation matrix R\n\n\n\n\n\nrotate!(surfaces, R, r = [0,0,0])\n\nRotate the surfaces in surfaces about point r using the rotation matrix R\n\n\n\n\n\nrotate!(grid, R, r = [0,0,0])\n\nRotate the grid points in grid about point r using the rotation matrix R\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.reflect-Tuple{AbstractMatrix{T} where T}","page":"Library","title":"VortexLattice.reflect","text":"reflect(surface)\n\nReflects the panels in surface across the X-Z plane\n\n\n\n\n\n","category":"method"},{"location":"library/#Reference-Parameters-and-Frames","page":"Library","title":"Reference Parameters and Frames","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Reference\nAbstractFrame\nBody\nStability\nWind","category":"page"},{"location":"library/#VortexLattice.Reference","page":"Library","title":"VortexLattice.Reference","text":"Reference(S, c, b, r)\n\nReference quantities.\n\nArguments\n\nS: reference area\nc: reference chord\nb: reference span\nr: reference location for all rotations/moments\nV: reference velocity (magnitude)\n\n\n\n\n\n","category":"type"},{"location":"library/#VortexLattice.AbstractFrame","page":"Library","title":"VortexLattice.AbstractFrame","text":"AbstractFrame\n\nSupertype for the different possible reference frames used by this package.\n\n\n\n\n\n","category":"type"},{"location":"library/#VortexLattice.Body","page":"Library","title":"VortexLattice.Body","text":"Body <: AbstractFrame\n\nReference frame aligned with the global X-Y-Z axes\n\n\n\n\n\n","category":"type"},{"location":"library/#VortexLattice.Stability","page":"Library","title":"VortexLattice.Stability","text":"Stability <: AbstractFrame\n\nReference frame rotated from the body frame about the y-axis to be aligned with the freestream alpha.\n\n\n\n\n\n","category":"type"},{"location":"library/#VortexLattice.Wind","page":"Library","title":"VortexLattice.Wind","text":"Wind <: AbstractFrame\n\nReference frame rotated to be aligned with the freestream alpha and beta\n\n\n\n\n\n","category":"type"},{"location":"library/#Freestream-Parameters","page":"Library","title":"Freestream Parameters","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Freestream\ntrajectory_to_freestream","category":"page"},{"location":"library/#VortexLattice.Freestream","page":"Library","title":"VortexLattice.Freestream","text":"Freestream([Vinf,] alpha, beta, Omega)\n\nDefines the freestream and rotational velocity properties.\n\nArguments\n\nVinf: Freestream velocity\nalpha: angle of attack (rad)\nbeta: sideslip angle (rad)\nOmega: rotation vector (p, q, r) of the body frame about the reference center.   Uses standard coordinate system from dynamics (positve p roll right wing down to turn right, positive q is pitch nose up, positive r is yaw nose to the right)\n\n\n\n\n\n","category":"type"},{"location":"library/#VortexLattice.trajectory_to_freestream","page":"Library","title":"VortexLattice.trajectory_to_freestream","text":"trajectory_to_freestream(dt; kwargs...)\n\nConvert trajectory parameters into freestream velocity parameters (see Freestream) at a collection of time steps.\n\nArguments:\n\ndt: Time step vector (seconds)\n\nKeyword Arguments:\n\nXdot = zeros(length(dt)): Global frame x-velocity for each time step\nYdot = zeros(length(dt)): Global frame y-velocity for each time step\nZdot = zeros(length(dt)): Global frame z-velocity for each time step\np = zeros(length(dt)): Angular velocity about x-axis for each time step\nq = zeros(length(dt)): Angular velocity about y-axis for each time step\nr = zeros(length(dt)): Angular velocity about z-axis for each time step\nphi0 = 0: Roll angle for initial time step\ntheta0 = 0: Pitch angle for initial time step\npsi0 = 0: Yaw angle for initial time step\n\n\n\n\n\n","category":"function"},{"location":"library/#Performing-an-Analysis","page":"Library","title":"Performing an Analysis","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"System\nSystem()\nsteady_analysis\nsteady_analysis!\nunsteady_analysis\nunsteady_analysis!","category":"page"},{"location":"library/#VortexLattice.System","page":"Library","title":"VortexLattice.System","text":"System{TF}\n\nContains pre-allocated storage for internal system variables.\n\nFields:\n\nAIC: Aerodynamic influence coefficient matrix from the surface panels\nw: Normal velocity at the control points from external sources and wakes\nΓ: Circulation strength of the surface panels\nV: Velocity at the wake vertices for each surface\nsurfaces: Surfaces, represented by matrices of surface panels\nproperties: Surface panel properties for each surface\nwakes: Wake panel properties for each surface\ntrefftz: Trefftz panels associated with each surface\nreference: Pointer to reference parameters associated with the system (see Reference)\nfreestream: Pointer to current freestream parameters associated with the system (see Freestream)\nsymmetric: Flags indicating whether each surface is symmetric across the X-Z plane\nnwake: Number of chordwise wake panels to use from each wake in wakes,\nsurface_id: Surface ID for each surface.  The finite core model is disabled  when calculating the influence of surfaces/wakes that share the same ID.\ntrailing_vortices: Flags to enable/disable trailing vortices\nwake_finite_core: Flag for each wake indicating whether the finite core  model should be enabled when calculating the wake's influence on itself and  surfaces/wakes with the same surface ID.\nnear_field_analysis: Flag indicating whether a near field analysis has been  performed for the current system state\nderivatives: Flag indicating whether the derivatives with respect to the  freestream variables have been calculated\ndw: Derivatives of the R.H.S. with respect to the freestream variables\ndΓ: Derivatives of the circulation strength with respect to the freestream variables\ndproperties: Derivatives of the panel properties with respect to the freestream variables\nwake_shedding_locations: Wake shedding locations for each surface\nVcp: Velocity due to surface motion at the control points\nVh: Velocity due to surface motion at the horizontal bound vortex centers\nVv: Velocity due to surface motion at the vertical bound vortex centers\nVte: Velocity due to surface motion at the trailing edge vertices\ndΓdt: Derivative of the circulation strength with respect to non-dimensional time\n\n\n\n\n\n","category":"type"},{"location":"library/#VortexLattice.System-Tuple{}","page":"Library","title":"VortexLattice.System","text":"System([TF], surfaces; kwargs...)\n\nReturn an object of type System with pre-allocated storage for internal system variables\n\nArguments:\n\nTF: Floating point type, defaults to the floating point type used by surface\nsurfaces:      Either:       - One or more grids of shape (3, nc+1, ns+1) which represents lifting surfaces,       or       - One or more matrices of surface panels (see SurfacePanel) of         shape (nc, ns)      where nc is the number of chordwise panels and ns is the number of      spanwise panels\n\nKeyword Arguments:\n\nnw: Number of chordwise wake panels to initialize for each surface. Defaults to  zero wake panels for each surface.\n\n\n\n\n\n","category":"method"},{"location":"library/#VortexLattice.steady_analysis","page":"Library","title":"VortexLattice.steady_analysis","text":"steady_analysis(surfaces, reference, freestream; kwargs...)\n\nPerform a steady vortex lattice method analysis.  Return an object of type System containing the system state.\n\nArguments\n\nsurfaces:\nVector of grids of shape (3, nc+1, ns+1) which represent lifting surfaces\nor\nVector of matrices of shape (nc, ns) containing surface panels (see\nSurfacePanel) where nc is the number of chordwise panels and ns is the number of spanwise panels\nreference: Reference parameters (see Reference)\nfreestream: Freestream parameters (see Freestream)\n\nKeyword Arguments\n\nsymmetric: Flag for each surface indicating whether a mirror image across  the X-Z plane should be used when calculating induced velocities. Defaults to  false for each surface\nwakes: Matrix of wake panels (see WakePanel) for each surface.  Each  matrix has shape (nw, ns) where nw is the number of chordwise wake panels  and ns is the number of spanwise panels for each surface, defaults to no  wake panels for each surface\nnwake: Number of chordwise wake panels to use from each wake in wakes,  defaults to all wake panels for each surface\nsurface_id: Surface ID for each surface.  The finite core model is disabled  when calculating the influence of surfaces/wakes that share the same ID.  By default, all surfaces are assigned their own IDs\nwake_finite_core: Flag for each wake indicating whether the finite core  model should be enabled when calculating a wake's influence on itself and  surfaces/wakes with the same surface ID.  Defaults to true for each surface.\ntrailing_vortices: Flags to enable/disable trailing vortices for each surface,  defaults to true for each surface\nxhat: Direction in which to shed trailing vortices, defaults to [1, 0, 0]\nadditional_velocity: Function which defines additional velocity as a  function of location.\nfcore: function which sets the finite core size for each surface based on  the chord length and/or the panel width. Defaults to (c, Δs) -> 1e-3.  Only used for grid inputs.\ncalculate_influence_matrix: Flag indicating whether the aerodynamic influence  coefficient matrix has already been calculated.  Re-using the same AIC matrix  will reduce calculation times when the underlying geometry has not changed.  Defaults to true.  Note that this argument is only valid for the pre-allocated  version of this function.\nnear_field_analysis: Flag indicating whether a near field analysis should be  performed to obtain panel velocities, circulation, and forces. Defaults to true.\nderivatives: Flag indicating whether the derivatives with respect  to the freestream variables should be calculated. Defaults to true.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.steady_analysis!","page":"Library","title":"VortexLattice.steady_analysis!","text":"steady_analysis!(system, surfaces, reference, freestream; kwargs...)\n\nPre-allocated version of steady_analysis.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.unsteady_analysis","page":"Library","title":"VortexLattice.unsteady_analysis","text":"unsteady_analysis(surfaces, reference, freestream, dt; kwargs...)\n\nPerform a unsteady vortex lattice method analysis.  Return an object of type System containing the final system state, a matrix of surface panels (see SurfacePanel for each surface at each time step, a matrix of surface panel properties (see PanelProperties) for each surface at each time step, and a matrix of wake panels (see WakePanel) for each surface at each time step.\n\nArguments\n\nsurfaces:\nGrids of shape (3, nc+1, ns+1) which represent lifting surfaces or\nMatrices of surface panels (see SurfacePanel) of shape\n(nc, ns)  where nc is the number of chordwise panels and ns is the number of  spanwise panels. Alternatively, a vector containing surface shapes/positions  at each time step (including at t=0) may be provided to model  moving/deforming lifting surfaces.\nreference: Reference parameters (see Reference)\nfreestream: Freestream parameters for each time step (see Freestream)\ndt: Time step vector\n\nKeyword Arguments\n\nsymmetric: Flags indicating whether a mirror image (across the X-Z plane) should  be used when calculating induced velocities, defaults to false for each surface\ninitial_wakes: Vector of initial wakes corresponding to each surface, represented  by matrices of wake panels (see WakePanel) of shape (nw, ns) where  nw is the number of chordwise wake panels and ns is the number of  spanwise panels. Defaults to no wake panels for each surface\ninitial_circulation: Vector containing the initial circulation of all surface  panels in the system.  Defaults to zeros(N) where N is the total number  of surface panels in surfaces.\nnwake: Maximum number of wake panels in the chordwise direction for each  surface.  Defaults to length(dx) for all surfaces.\nsurface_id: Surface ID for each surface.  The finite core model is disabled  when calculating the influence of surfaces/wakes that share the same ID.\nwake_finite_core: Flag for each wake indicating whether the finite core  model should be enabled when calculating the wake's influence on itself and  surfaces/wakes with the same surface ID.  Defaults to true for each surface.\nsave: Time indices at which to save the time history, defaults to 1:length(dx)\ncalculate_influence_matrix: Flag indicating whether the aerodynamic influence  coefficient matrix needs to be calculated.  Re-using the same AIC matrix  will (slightly) reduce calculation times when the underlying geometry has not changed.  Defaults to true.  Note that this argument only affects the pre-allocated  version of this function.\nnear_field_analysis: Flag indicating whether a near field analysis should be  performed to obtain panel velocities, circulation, and forces for the final  time step. Defaults to true.\nderivatives: Flag indicating whether the derivatives with respect to the  freestream variables should be calculated for the final time step. Defaults  to true.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.unsteady_analysis!","page":"Library","title":"VortexLattice.unsteady_analysis!","text":"unsteady_analysis!(system, surfaces, reference, freestream, dt; kwargs...)\n\nPre-allocated version of unsteady_analysis.\n\n\n\n\n\n","category":"function"},{"location":"library/#Near-Field-Forces-and-Moments","page":"Library","title":"Near Field Forces and Moments","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"PanelProperties\nget_surface_properties\nbody_forces(system::System{TF}; frame = Body()) where TF\nbody_forces_history\nlifting_line_coefficients\nlifting_line_coefficients!","category":"page"},{"location":"library/#VortexLattice.PanelProperties","page":"Library","title":"VortexLattice.PanelProperties","text":"PanelProperties\n\nPanel specific properties calculated during the vortex lattice method analysis.\n\nFields\n\ngamma: Vortex ring circulation strength, normalized by the reference velocity\nvelocity: Local velocity at the panel's bound vortex center, normalized by  the reference velocity\ncfb: Net force on the panel's bound vortex, as calculated using the  Kutta-Joukowski theorem, normalized by the reference dynamic pressure and area\ncfl: Force on the left bound vortex from this panel's vortex ring, as  calculated by the Kutta-Joukowski theorem, normalized by the reference  dynamic pressure and area\ncfr: Force on the right bound vortex from this panel's vortex ring, as  calculated by the Kutta-Joukowski theorem, normalized by the reference  dynamic pressure and area\n\n\n\n\n\n","category":"type"},{"location":"library/#VortexLattice.get_surface_properties","page":"Library","title":"VortexLattice.get_surface_properties","text":"get_surface_properties(system)\n\nReturn a vector of surface panel properties for each surface, stored as matrices of panel properties (see PanelProperties) of shape (nc, ns) where nc is the number of chordwise panels and ns is the number of spanwise panels\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.body_forces-Union{Tuple{System{TF}}, Tuple{TF}} where TF","page":"Library","title":"VortexLattice.body_forces","text":"body_forces(system; kwargs...)\n\nReturn the body force coefficients given the panel properties for surfaces\n\nNote that this function assumes that a near-field analysis has already been performed to obtain the panel forces.\n\nArguments\n\nsystem: Object of type System which holds system properties\n\nKeyword Arguments\n\nframe: frame in which to return CF and CM, options are Body() (default), Stability(), and Wind()`\n\n\n\n\n\n","category":"method"},{"location":"library/#VortexLattice.body_forces_history","page":"Library","title":"VortexLattice.body_forces_history","text":"body_forces_history(system, surface_history, property_history; frame=Body())\n\nReturn the body force coefficients CF, CM at each time step in property_history.\n\nArguments:\n\nsystem: Object of type System which holds system properties\nsurface_history: Vector of surfaces at each time step, where each surface is  represented by a matrix of surface panels (see SurfacePanel) of shape  (nc, ns) where nc is the number of chordwise panels and ns is the number  of spanwise panels\nproperty_history: Vector of surface properties for each surface at each  time step, where surface properties are represented by a matrix of panel  properties (see PanelProperties) of shape (nc, ns) where nc is  the number of chordwise panels and ns is the number of spanwise panels\n\nKeyword Arguments\n\nframe: frame in which to return CF and CM, options are Body() (default), Stability(), and Wind()`\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.lifting_line_coefficients","page":"Library","title":"VortexLattice.lifting_line_coefficients","text":"lifting_line_coefficients(system, r, c; frame=Body())\n\nReturn the force and moment coefficients (per unit span) for each spanwise segment of a lifting line representation of the geometry.\n\nThis function requires that a near-field analysis has been performed on system to obtain panel forces.\n\nArguments\n\nsystem: Object of type System that holds precalculated  system properties.\nr: Vector with length equal to the number of surfaces, with each element  being a matrix with size (3, ns+1) which contains the x, y, and z coordinates  of the resulting lifting line coordinates\nc: Vector with length equal to the number of surfaces, with each element  being a vector of length ns+1 which contains the chord lengths at each  lifting line coordinate.\n\nKeyword Arguments\n\nframe: frame in which to return cf and cm, possible options are  Body() (default), Stability(), and Wind()`\n\nReturn Arguments:\n\ncf: Vector with length equal to the number of surfaces, with each element  being a matrix with size (3, ns) which contains the x, y, and z direction  force coefficients (per unit span) for each spanwise segment.\ncm: Vector with length equal to the number of surfaces, with each element  being a matrix with size (3, ns) which contains the x, y, and z direction  moment coefficients (per unit span) for each spanwise segment.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.lifting_line_coefficients!","page":"Library","title":"VortexLattice.lifting_line_coefficients!","text":"lifting_line_coefficients!(cf, cm, system, r, c; frame=Body())\n\nIn-place version of lifting_line_coefficients\n\n\n\n\n\n","category":"function"},{"location":"library/#Far-Field-Drag","page":"Library","title":"Far Field Drag","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"far_field_drag","category":"page"},{"location":"library/#VortexLattice.far_field_drag","page":"Library","title":"VortexLattice.far_field_drag","text":"far_field_drag(system)\n\nComputes induced drag using the Trefftz plane (far field method).\n\nNote that this function assumes that the circulation distribution has already been computed and is present in system\n\nArguments\n\nsystem: Pre-allocated system properties\n\n\n\n\n\nfar_field_drag(receiving, sending, reference, symmetric)\n\nComputes the induced drag on receiving from sending using the Trefftz plane analysis.\n\nArguments\n\nreceiving: Vector of receiving Trefftz panels (see TrefftzPanel)\nsending: Vector of sending Trefftz panels (see TrefftzPanel)\nreference: Reference parameters (see Reference)\nsymmetric: Flag indicating whether a mirror image of the panels in surface,  should be used when calculating induced velocities\n\n\n\n\n\n","category":"function"},{"location":"library/#Body-and-Stability-Derivatives","page":"Library","title":"Body and Stability Derivatives","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"body_derivatives\nstability_derivatives","category":"page"},{"location":"library/#VortexLattice.body_derivatives","page":"Library","title":"VortexLattice.body_derivatives","text":"body_derivatives(system, surfaces, reference, freestream; kwargs...)\n\nReturns the derivatives of the body forces and moments with respect to the freestream velocity components (u, v, w) and the angular velocity components (p, q, r) in the body frame.\n\nThe derivatives are returned as two named tuples: dCF, dCM\n\nNote that the derivatives with respect to the freestream variables of the panel forces must have been previously computed and stored in system\n\nArguments:\n\nsystem: Object of type System which holds system properties\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.stability_derivatives","page":"Library","title":"VortexLattice.stability_derivatives","text":"stability_derivatives(system)\n\nReturns the derivatives of the body forces and moments in the stability frame with respect to the freestream velocity components (alpha, beta) and the angular velocity components (p, q, r) in the stability frame.\n\nThe derivatives are returned as two named tuples: dCF, dCM\n\nNote that the derivatives with respect to the freestream variables of the panel forces must have been previously computed and stored in system\n\nArguments:\n\nsystem: Object of type System which holds system properties\n\n\n\n\n\n","category":"function"},{"location":"library/#Visualization","page":"Library","title":"Visualization","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"write_vtk","category":"page"},{"location":"library/#VortexLattice.write_vtk","page":"Library","title":"VortexLattice.write_vtk","text":"write_vtk(name, surfaces, [surface_properties]; kwargs...)\nwrite_vtk(name, wakes; kwargs...)\nwrite_vtk(name, surfaces, wakes, [surface_properties]; kwargs...)\n\nWrite geometry from surfaces and/or wakes to Paraview files for visualization.\n\nArguments\n\nname: Base name for the generated files\nsurfaces:\nVector of grids of shape (3, nc+1, ns+1) which represent lifting surfaces\nor\nVector of matrices of shape (nc, ns) containing surface panels (see\nSurfacePanel) where nc is the number of chordwise panels and ns is the number of spanwise panels\nwakes: (optional) Vector of wakes corresponding to each surface, represented  by matrices of wake panels (see WakePanel) of shape (nw, ns) where  nw is the number of chordwise wake panels and ns is the number of  spanwise panels.\nsurface_properties: (optional) Vector of surface panel properties for each  surface, stored as matrices of panel properties (see PanelProperties)  of shape (nc, ns) where nc is the number of chordwise panels and ns is  the number of spanwise panels\n\nKeyword Arguments:\n\nsymmetric: (required if surface_properties is provided) Flags indicating whether a  mirror image (across the X-Z plane) was used when calculating induced velocities  for each surface.\ntrailing_vortices: Flag indicating whether the model uses trailing vortices.  Defaults to true when wake panels are absent, false otherwise\nxhat: Direction in which trailing vortices extend if used. Defaults to [1, 0, 0].\nwake_length: Distance to extend trailing vortices. Defaults to 10\nmetadata: Dictionary of metadata to include in generated files\n\n\n\n\n\nwrite_vtk(name, surface_history, property_history, wake_history; kwargs...)\n\nWrites unsteady simulation geometry to Paraview files for visualization.\n\nArguments\n\nname: Base name for the generated files\nsurface_history: Vector of surfaces at each time step, where each surface is  represented by a matrix of surface panels (see SurfacePanel) of shape  (nc, ns) where nc is the number of chordwise panels and ns is the number  of spanwise panels\nproperty_history: Vector of surface properties for each surface at each  time step, where surface properties are represented by a matrix of panel  properties (see PanelProperties) of shape (nc, ns) where nc is  the number of chordwise panels and ns is the number of spanwise panels\nwake_history: Vector of wakes corresponding to each surface at each time step,  where each wake is represented by a matrix of wake panels (see WakePanel)  of shape (nw, ns) where nw is the number of chordwise wake panels and  ns is the number of spanwise panels.\ndt: Time step vector\n\nKeyword Arguments:\n\nsymmetric: (required if properties is provided) Flags indicating whether a  mirror image (across the X-Z plane) was used when calculating induced velocities  for each surface.\nwake_length: Distance to extend trailing vortices. Defaults to 10\nmetadata: Dictionary of metadata to include in generated files\n\n\n\n\n\n","category":"function"},{"location":"library/#Private-API","page":"Library","title":"Private API","text":"","category":"section"},{"location":"library/#Geometry","page":"Library","title":"Geometry","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"VortexLattice.linearinterp\nVortexLattice.spanwise_spacing\nVortexLattice.chordwise_spacing\nVortexLattice.interpolate_grid\nVortexLattice.update_surface_panels!\nVortexLattice.trailing_edge_points\nVortexLattice.repeated_trailing_edge_points\nVortexLattice.flipy\nVortexLattice.on_symmetry_plane\nVortexLattice.not_on_symmetry_plane","category":"page"},{"location":"library/#VortexLattice.linearinterp","page":"Library","title":"VortexLattice.linearinterp","text":"linearinterp(eta, rstart, rend)\n\nLinearly interpolate between rstart and rend where eta is the fraction between 0 (rstart) and 1 (rend)\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.spanwise_spacing","page":"Library","title":"VortexLattice.spanwise_spacing","text":"spanwise_spacing(n, spacing::AbstractSpacing)\n\nDistribute n panel endpoints and n-1 panel midpoints on the interval between 0 and 1 according to the discretization strategy in spacing.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.chordwise_spacing","page":"Library","title":"VortexLattice.chordwise_spacing","text":"chordwise_spacing(n, spacing::AbstractSpacing)\n\nDistribute n panel edge, n-1 vortex, and n-1 control point chordwise locations on the interval between 0 and 1 according to the discretization strategy in spacing.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.interpolate_grid","page":"Library","title":"VortexLattice.interpolate_grid","text":"interpolate_grid(xyz, eta, interp; xdir=0, ydir=1)\n\nInterpolates the grid xyz along direction dir\n\nArguments\n\nxyz: Grid of size (3, ni, nj)\neta: New (normalized) coordinates in direction dir (0 <= eta <= 1)\ninterp: Interpolation method of form ypt = f(x,y,xpt)\nxdir: Independent variable direction, defaults to arc length\nydir: Dependent variable direction xyz (i=1, j=2)\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.update_surface_panels!","page":"Library","title":"VortexLattice.update_surface_panels!","text":"update_surface_panels!(surface, grid; fcore = (c, Δs) -> 1e-3)\n\nUpdates the surface panels in surface to correspond to the grid coordinates in grid.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.trailing_edge_points","page":"Library","title":"VortexLattice.trailing_edge_points","text":"trailing_edge_points(surface[s])\n\nReturn points on the trailing edge of each surface.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.repeated_trailing_edge_points","page":"Library","title":"VortexLattice.repeated_trailing_edge_points","text":"repeated_trailing_edge_points(surface[s])\n\nGenerates a dictionary of the form Dict((isurf, i) => [(jsurf1, j1), (jsurf2, j2)...] which defines repeated trailing edge points.  Trailing edge point i on surface isurf is repeated on surface jsurf1 at point j1, jsurf2 at point j2, and so forth.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.flipy","page":"Library","title":"VortexLattice.flipy","text":"flipy(r)\n\nFlip sign of y-component of vector r (used for symmetry)\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.on_symmetry_plane","page":"Library","title":"VortexLattice.on_symmetry_plane","text":"on_symmetry_plane(args...; tol=eps())\n\nTest whether points in args are on the symmetry plane (y = 0)\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.not_on_symmetry_plane","page":"Library","title":"VortexLattice.not_on_symmetry_plane","text":"not_on_symmetry_plane(args...; tol=eps())\n\nTest whether and of the points in args are not on the symmetry plane (y = 0)\n\n\n\n\n\n","category":"function"},{"location":"library/#Surface-Panels","page":"Library","title":"Surface Panels","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"VortexLattice.top_left\nVortexLattice.top_center\nVortexLattice.top_right\nVortexLattice.bottom_left\nVortexLattice.bottom_center\nVortexLattice.bottom_right\nVortexLattice.controlpoint\nVortexLattice.normal(panel::SurfacePanel)\nVortexLattice.get_core_size\nVortexLattice.reflect(panel::SurfacePanel)\nVortexLattice.left_center\nVortexLattice.right_center\nVortexLattice.top_vector\nVortexLattice.left_vector\nVortexLattice.right_vector\nVortexLattice.bottom_vector","category":"page"},{"location":"library/#VortexLattice.top_left","page":"Library","title":"VortexLattice.top_left","text":"top_left(panel::SurfacePanel)\n\nReturn the top left vertex of the vortex ring associated with panel\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.top_center","page":"Library","title":"VortexLattice.top_center","text":"top_center(panel::SurfacePanel)\n\nReturn the top center vertex of the vortex ring associated with panel\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.top_right","page":"Library","title":"VortexLattice.top_right","text":"top_right(panel::SurfacePanel)\n\nReturn the top right vertex of the vortex ring associated with panel\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.bottom_left","page":"Library","title":"VortexLattice.bottom_left","text":"bottom_left(panel::SurfacePanel)\n\nReturn the bottom left vertex of the vortex ring associated with panel\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.bottom_center","page":"Library","title":"VortexLattice.bottom_center","text":"bottom_center(panel::SurfacePanel)\n\nReturn the bottom center vertex of the vortex ring associated with panel\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.bottom_right","page":"Library","title":"VortexLattice.bottom_right","text":"bottom_right(panel::SurfacePanel)\n\nReturn the bottom right vertex of the vortex ring associated with panel\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.controlpoint","page":"Library","title":"VortexLattice.controlpoint","text":"controlpoint(panel::SurfacePanel)\n\nReturn the control point of panel (typically located at the 3/4 chord)\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.normal-Tuple{SurfacePanel}","page":"Library","title":"VortexLattice.normal","text":"normal(panel::SurfacePanel)\n\nReturn the normal vector of panel at the panel control point\n\n\n\n\n\n","category":"method"},{"location":"library/#VortexLattice.get_core_size","page":"Library","title":"VortexLattice.get_core_size","text":"get_core_size(panel::SurfacePanel)\n\nReturn the core size (smoothing parameter) corresponding to the vortex ring associated with panel\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.reflect-Tuple{SurfacePanel}","page":"Library","title":"VortexLattice.reflect","text":"reflect(panel::SurfacePanel)\n\nReflect panel across the X-Z plane.\n\n\n\n\n\n","category":"method"},{"location":"library/#VortexLattice.left_center","page":"Library","title":"VortexLattice.left_center","text":"left_center(panel::SurfacePanel)\n\nReturn the center of the left bound vortex of the vortex ring associated with panel\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.right_center","page":"Library","title":"VortexLattice.right_center","text":"right_center(panel::SurfacePanel)\n\nReturn the center of the right bound vortex of the vortex ring associated with panel\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.top_vector","page":"Library","title":"VortexLattice.top_vector","text":"top_vector(panel::SurfacePanel)\n\nReturn the path of the top bound vortex of the vortex ring associated with panel\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.left_vector","page":"Library","title":"VortexLattice.left_vector","text":"left_vector(panel)\n\nReturn the path of the left bound vortex of the vortex ring associated with panel\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.right_vector","page":"Library","title":"VortexLattice.right_vector","text":"right_vector(panel)\n\nReturn the path of the right bound vortex of the vortex ring associated with panel\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.bottom_vector","page":"Library","title":"VortexLattice.bottom_vector","text":"bottom_vector(panel)\n\nReturn the path of the bottom bound vortex of the vortex ring associated with panel\n\n\n\n\n\n","category":"function"},{"location":"library/#Wake-Panels","page":"Library","title":"Wake Panels","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"VortexLattice.update_wake_shedding_locations!\nVortexLattice.set_circulation_strength\nVortexLattice.circulation_strength\nVortexLattice.get_wake_velocities!\nVortexLattice.translate_wake\nVortexLattice.translate_wake!\nVortexLattice.shed_wake!\nVortexLattice.rowshift!","category":"page"},{"location":"library/#VortexLattice.update_wake_shedding_locations!","page":"Library","title":"VortexLattice.update_wake_shedding_locations!","text":"update_wake_shedding_locations!(wakes, wake_shedding_locations,\n    surfaces, ref, fs, dt, additional_velocity, Vte, nwake, eta)\n\nUpdate the wake shedding locations.  Also update the first chordwise wake panels to account for the new wake shedding location\n\nArguments\n\nwakes: Vector of wakes corresponding to each surface, represented by matrices  of wake panels (see WakePanel) of shape (nw, ns) where nw is the  number of chordwise wake panels and ns is the number of spanwise panels.\nwake_shedding_locations: Shedding location coordinates for each surface for  each trailing edge vertex.\nsurfaces: Vector of surfaces, represented by matrices of surface panels  (see SurfacePanel of shape (nc, ns) where nc is the number of  chordwise panels and ns is the number of spanwise panels\nreference: Reference parameters (see Reference)\nfreestream: Freestream parameters (see Freestream)\ndt: Time step (seconds)\nadditional_velocity: Function defining additional velocity field\nVte: Velocity experienced at the trailing edge due to surface motion.\nnwake: Number of chordwise wake panels to use from each wake in wakes\neta: Time step fraction used to define separation between trailing  edge and wake shedding location.  Typical values range from 0.2-0.3.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.set_circulation_strength","page":"Library","title":"VortexLattice.set_circulation_strength","text":"set_circulation_strength(panel::WakePanel, gamma)\n\nReturn a copy of panel with the circulation strength gamma\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.circulation_strength","page":"Library","title":"VortexLattice.circulation_strength","text":"circulation_strength(panel::WakePanel)\n\nReturn the circulation strength of the wake panel.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.get_wake_velocities!","page":"Library","title":"VortexLattice.get_wake_velocities!","text":"get_wake_velocities!(wake_velocities, surfaces, wakes, ref, fs, Γ,\n    additional_velocity, Vte, symmetric, repeated_points, nwake,\n    surface_id, wake_finite_core, wake_shedding_locations, trailing_vortices, xhat)\n\nArguments\n\nwake_velocities: Velocities at the corners of the wake panels in wakes\nsurfaces: Vector of surfaces, represented by matrices of surface panels  (see SurfacePanel of shape (nc, ns) where nc is the number of  chordwise panels and ns is the number of spanwise panels\nwakes: Vector of wakes corresponding to each surface, represented by matrices  of wake panels (see WakePanel) of shape (nw, ns) where nw is the  number of chordwise wake panels and ns is the number of spanwise panels.\nreference: Reference parameters (see Reference)\nfreestream: Freestream parameters (see Freestream)\nΓ: Circulation of all surface panels stored in a single vector\nadditional_velocity: Function defining additional velocity field\nVte: Velocity at the trailing edge vertices on each surface due to surface motion\nsymmetric: (required) Flag for each surface indicating whether a mirror  image across the X-Z plane should be used when calculating induced velocities\nrepeated_points: Dictionary of the form Dict((isurf, i) => [(jsurf1, j1),  (jsurf2, j2)...] which defines repeated trailing edge points.  Trailing edge  point i on surface isurf is repeated on surface jsurf1 at point j1,  jsurf2 at point j2, and so forth. See repeated_trailing_edge_points\nnwake: Number of chordwise wake panels to use from each wake in wakes,  defaults to all provided wake panels\nsurface_id: Surface ID for each surface.  The finite core model is disabled  when calculating the influence of surfaces/wakes that share the same ID.\nwake_finite_core: Flag for each wake indicating whether the finite core  model should be enabled when calculating the wake's influence on itself and  surfaces/wakes with the same surface ID.  Defaults to true for each surface.\nwake_shedding_locations: Shedding location coordinates for each surface for  each trailing edge vertex.\ntrailing_vortices: Flags to enable/disable trailing vortices, defaults to  true for each surface\nxhat: Direction in which to shed trailing vortices, defaults to [1, 0, 0]\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.translate_wake","page":"Library","title":"VortexLattice.translate_wake","text":"translate_wake(panel, wake_velocities, dt)\n\nReturn a translated copy of the wake panel panel given the wake corner velocities wake_velocities and the time step dt\n\nArguments\n\npanel: Wake panel (of type WakePanel)\nwake_velocities: Matrix containing the velocities at each of the four corners  of panel\ndt: Time step (seconds)\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.translate_wake!","page":"Library","title":"VortexLattice.translate_wake!","text":"translate_wake!(wake, wake_velocities, dt; nwake = size(wake, 1))\n\nTranslate the wake panels in wake given the corner velocities wake_velocities and the time step dt.\n\nArguments\n\nwake: Matrix of wake panels (see WakePanel) of shape (nw, ns)  where nw is the number of chordwise wake panels and ns is the number of  spanwise panels, defaults to no wake panels\nwake_velocities: Velocities at each of the vertices corresponding to the  wake panels in wake\ndt: Time step\n\nKeyword Arguments\n\nnwake: Number of chordwise wake panels to use from wake, defaults to all  provided wake panels\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.shed_wake!","page":"Library","title":"VortexLattice.shed_wake!","text":"shed_wake!(wake, wake_shedding_locations, wake_velocities, dt, surface, Γ, nwake)\n\nShed a new wake panel from the wake shedding locations and translate existing wake panels.\n\nArguments\n\nwake: Matrix of wake panels (see WakePanel) of shape (nw, ns)  where nw is the number of chordwise wake panels and ns is the number of  spanwise panels\nwake_shedding_locations: Vector of length ns which stores the coordinates  where wake panels are shed from the trailing edge of surface.\nwake_velocities: Velocities at each of the vertices corresponding to the  wake panels in wake\ndt: Time step (seconds)\nsurface: Matrix of surface panels (see SurfacePanel) of shape  (nc, ns) where nc is the number of chordwise panels and ns is the number  of spanwise panels\nΓ: Circulation strength of each surface panel in surface\nnwake: Number of chordwise wake panels to use from wake, defaults to all  provided wake panels\n\n\n\n\n\nshed_wake!(wakes, wake_shedding_locations, wake_velocities, dt, surfaces, Γ, nwake)\n\nShed a new wake panel from the wake shedding locations and translate existing wake panels.\n\nArguments\n\nwakes: Vector of wakes corresponding to each surface, represented by matrices  of wake panels (see WakePanel) of shape (nw, ns) where nw is the  number of chordwise wake panels and ns is the number of spanwise panels.\nwake_shedding_locations: Shedding location coordinates for each surface for  each trailing edge vertex.\nwake_velocities: Velocities at each of the vertices corresponding to the  wake panels in wake\ndt: Time step (seconds)\nsurfaces: Vector of surfaces, represented by matrices of surface panels  (see SurfacePanel of shape (nc, ns) where nc is the number of  chordwise panels and ns is the number of spanwise panels\nΓ: Circulation strength of each surface panel in surfaces\nnwake: Number of chordwise wake panels to use from each wake in wakes,  defaults to all provided wake panels\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.rowshift!","page":"Library","title":"VortexLattice.rowshift!","text":"rowshift!(A)\n\nCircularly shifts the rows of a matrix down one row.\n\n\n\n\n\n","category":"function"},{"location":"library/#Induced-Velocity","page":"Library","title":"Induced Velocity","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"VortexLattice.bound_induced_velocity\nVortexLattice.trailing_induced_velocity\nVortexLattice.ring_induced_velocity\nVortexLattice.influence_coefficients!\nVortexLattice.update_trailing_edge_coefficients!\nVortexLattice.induced_velocity\nVortexLattice.induced_velocity_derivatives","category":"page"},{"location":"library/#VortexLattice.bound_induced_velocity","page":"Library","title":"VortexLattice.bound_induced_velocity","text":"bound_induced_velocity(r1, r2, finite_core, core_size)\n\nCompute the induced velocity (per unit circulation) for a bound vortex, at a control point located at r1 relative to the start of the bound vortex and r2 relative to the end of the bound vortex\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.trailing_induced_velocity","page":"Library","title":"VortexLattice.trailing_induced_velocity","text":"trailing_induced_velocity(r1, r2, xhat, finite_core, core_size)\n\nCompute the induced velocity (per unit circulation) for a vortex trailing in the xhat direction, at a control point located at r relative to the start of the trailing vortex.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.ring_induced_velocity","page":"Library","title":"VortexLattice.ring_induced_velocity","text":"ring_induced_velocity(rcp, r11, r12, r21, r22; finite_core = false,\n    core_size = 0.0, symmetric = false, xhat = [1,0,0], top = true, bottom = true,\n    left = true, right = true, left_trailing = false, right_trailing = false,\n    reflected_top = true, reflected_bottom = true, reflected_left = true,\n    reflected_right = true, reflected_left_trailing = false, reflected_right_trailing = false)\n\nCompute the induced velocity (per unit circulation) for a vortex ring defined by the corners r11, r12, r21, and r22 at a control point located at rcp\n\nAlso returns the induced velocity resulting from shared edges with panels on the top, bottom, left, and right sides of the panel described by r11, r12, r21, and r22.\n\n\n\n\n\nring_induced_velocity(rcp, panel; kwargs...)\n\nCompute the velocity (per unit circulation) induced by panel at a control point located at rcp\n\nAlso returns the velocity induced by the shared edges of adjacent panels on the top, bottom, left, and right sides of panel.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.influence_coefficients!","page":"Library","title":"VortexLattice.influence_coefficients!","text":"influence_coefficients!(AIC, surface; kwargs...)\n\nConstruct the aerodynamic influence coefficient matrix for a single surface.\n\nArguments:\n\nsurface: Matrix of surface panels (see SurfacePanel) of shape  (nc, ns) where nc is the number of chordwise panels and ns is the number  of spanwise panels\n\nKeyword Arguments\n\nsymmetric: Flag indicating whether a mirror image of the panels in surface  should be used when calculating induced velocities.\nwake_shedding_locations: Wake shedding locations for the trailing edge  panels in surface\ntrailing_vortices: Flag to enable/disable trailing vortices.  Defaults to  true.\nxhat: Direction in which trailing vortices are shed if trailing_vortices = true.  Defaults to [1, 0, 0]\n\n\n\n\n\ninfluence_coefficients!(AIC, surfaces; kwargs...)\n\nConstruct the aerodynamic influence coefficient matrix for multiple surfaces.\n\nArguments:\n\nsurfaces: Vector of surfaces, represented by matrices of surface panels  (see SurfacePanel of shape (nc, ns) where nc is the number of  chordwise panels and ns is the number of spanwise panels\n\nKeyword Arguments:\n\nsymmetric: Flags indicating whether a mirror image (across the X-Z plane) should  be used when calculating induced velocities. Defaults to false for each surface.\nsurface_id: ID for each surface.  May be used to deactivate the finite core  model by setting all surface ID's to the same value.  Defaults to a unique ID  for each surface\nwake_shedding_locations: Wake shedding locations for the trailing edge panels of  each surface in surfaces\ntrailing_vortices: Flags to indicate whether trailing vortices are used for  each surface. Defaults to true for each surface.\nxhat: Direction in which trailing vortices are shed if trailing_vortices = true.  Defaults to [1, 0, 0]\n\n\n\n\n\ninfluence_coefficients!(AIC, receiving, sending; kwargs...)\n\nCompute the AIC coefficients corresponding to the influence of the panels in sending on the panels in receiving.\n\nKeyword Arguments\n\nfinite_core: Flag indicating whether the finite core model is enabled. Defaults  to true\nsymmetric: Flag indicating whether sending panels should be mirrored across the X-Z plane\nwake_shedding_locations: Wake shedding locations for the trailing edge panels in sending\ntrailing_vortices: Indicates whether trailing vortices are used. Defaults to true.\nxhat: Direction in which trailing vortices are shed if trailing_vortices = true.  Defaults to [1, 0, 0]\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.update_trailing_edge_coefficients!","page":"Library","title":"VortexLattice.update_trailing_edge_coefficients!","text":"update_trailing_edge_coefficients!(AIC, surface; kwargs...)\n\nConstruct the aerodynamic influence coefficient matrix for a single surface.\n\nArguments:\n\nsurface: Matrix of panels of shape (nc, ns) where nc is the number of  chordwise panels and ns is the number of spanwise panels\n\nKeyword Arguments\n\nsymmetric: Flag indicating whether a mirror image of the panels in surface  should be used when calculating induced velocities.\ntrailing_vortices: Flag to enable/disable trailing vortices.\nxhat: Direction in which trailing vortices are shed if trailing_vortices = true.  Defaults to [1, 0, 0]\n\n\n\n\n\nupdate_trailing_edge_coefficients!(AIC, surfaces; kwargs...)\n\nConstruct the aerodynamic influence coefficient matrix for multiple surfaces.\n\nArguments:\n\nsurfaces: Vector of surfaces, represented by matrices of panels of shape  (nc, ns) where nc is the number of chordwise panels and ns is the number  of spanwise panels\n\nKeyword Arguments:\n\nsymmetric: Flags indicating whether a mirror image (across the X-Z plane) should  be used when calculating induced velocities. Defaults to false for each surface.\nwake_shedding_locations: Shedding location coordinates for each surface for  each trailing edge vertex.\nsurface_id: ID for each surface.  May be used to deactivate the finite core  model by setting all surface ID's to the same value.  Defaults to a unique ID  for each surface\ntrailing_vortices: Flags to indicate whether trailing vortices are used for  each surface. Defaults to true for each surface.\nxhat: Direction in which trailing vortices are shed if trailing_vortices = true.  Defaults to [1, 0, 0]\n\n\n\n\n\nupdate_trailing_edge_coefficients!(AIC, receiving, sending; kwargs...)\n\nUpdate the AIC coefficients corresponding to the influence of the trailing edge panels in sending on the panels in receiving.\n\nKeyword Arguments\n\nfinite_core: Flag indicating whether the finite core model is enabled. Defaults  to true\nsymmetric: Flag indicating whether sending panels should be mirrored across the X-Z plane\nwake_shedding_locations: Wake shedding locations for the trailing edge panels in sending\ntrailing_vortices: Indicates whether trailing vortices are used. Defaults to true.\nxhat: Direction in which trailing vortices are shed if trailing_vortices = true.  Defaults to [1, 0, 0]\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.induced_velocity","page":"Library","title":"VortexLattice.induced_velocity","text":"induced_velocity(rcp, surface, Γ; kwargs...)\n\nCompute the velocity induced by the grid of panels in surface at control point rcp\n\n\n\n\n\ninduced_velocity(I::CartesianIndex, surface, Γ; kwargs...)\n\nCompute the velocity induced by the grid of panels in surface on the top bound vortex of panel I in surface.\n\n\n\n\n\ninduced_velocity(is::Integer, surface, Γ; kwargs...)\n\nCompute the velocity induced by the grid of panels in surface at the trailing edge vertex corresponding to index is\n\n\n\n\n\ninduced_velocity(rcp, wake::AbstractMatrix{<:WakePanel}; kwargs...)\n\nCompute the velocity induced by the grid of wake panels in wake at control point rcp\n\n\n\n\n\ninduced_velocity(I::CartesianIndex, wake; kwargs...)\n\nCompute the induced velocity from the grid of wake panels in wake at the vertex corresponding to index I\n\n\n\n\n\ninduced_velocity(rcp, surface, Γ = nothing, dΓ = nothing; kwargs...)\n\nCompute the induced velocity from the grid of panels in surface at rcp using the circulation strengths provided in Γ.\n\nKeyword Arguments\n\nnc: Number of panels in the chordwise direction. Defaults to size(surface, 1)\nns: Number of panels in the spanwise direction. Defaults to size(surface, 2)\nfinite_core: Flag indicating whether the finite core model should be used\nsymmetric: Flag indicating whether sending panels should be mirrored across the X-Z plane\nwake_shedding_locations: Wake shedding locations for the trailing edge panels in surface\ntrailing_vortices: Indicates whether trailing vortices are used. Defaults to true.\nxhat: Direction in which trailing vortices are shed if trailing_vortices = true.  Defaults to [1, 0, 0]\nskip_leading_edge = false: Indicates whether to skip the leading edge.  This flag  may be used to skip calculating the leading bound vortex of a wake when its  influence cancels exactly with the trailing bound vortex of a surface.\nskip_inside_edges = false: Indicates whether to skip all horizontal bound  vortices except those located at the leading and trailing edges.  This flag may be used to skip calculating a wake's (internal) horizontal  bound vortices during steady state simulations since the influence of adjacent  wake panels in a chordwise strip cancels exactly in steady state simulations.\nskip_trailing_edge = false: Indicates whether to skip the trailing edge.  The trailing edge is always skipped if trailing_vortices = true\nskip_top: Tuple containing panel indices whose top bound vortex is coincident with  rcp and should therefore be skipped.\nskip_bottom: Tuple containing panel indices whose bottom bound vortex is coincident with  rcp and should therefore be skipped.\nskip_left: Tuple containing panel indices whose left bound vortex is coincident with  rcp and should therefore be skipped.\nskip_right: Tuple containing panel indices whose right bound vortex is coincident with  rcp and should therefore be skipped.\nskip_left_trailing: Tuple containing panel indices whose left trailing vortex  is coincident with rcp and should therefore be skipped.\nskip_right_trailing: Tuple containing panel indices whose right trailing vortex  is coincident with rcp and should therefore be skipped.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.induced_velocity_derivatives","page":"Library","title":"VortexLattice.induced_velocity_derivatives","text":"induced_velocity_derivatives(rcp, surface, Γ, dΓ; kwargs...)\n\nCompute the velocity induced by the grid of panels in surface at control point rcp and its derivatives with respect to the freestream variables\n\n\n\n\n\ninduced_velocity_derivatives(I::CartesianIndex, surface, Γ, dΓ; kwargs...)\n\nCompute the velocity induced by the grid of panels in surface on the top bound of panel I in surface and its derivatives with respect to the freestream variables\n\n\n\n\n\n","category":"function"},{"location":"library/#Freestream","page":"Library","title":"Freestream","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"VortexLattice.body_to_stability\nVortexLattice.body_to_wind\nVortexLattice.stability_to_body\nVortexLattice.stability_to_wind\nVortexLattice.wind_to_body\nVortexLattice.wind_to_stability\nVortexLattice.body_to_stability_alpha\nVortexLattice.body_to_wind_derivatives\nVortexLattice.stability_to_body_alpha\nVortexLattice.stability_to_wind_beta\nVortexLattice.wind_to_body_derivatives\nVortexLattice.wind_to_stability_beta\nVortexLattice.freestream_velocity\nVortexLattice.freestream_velocity_derivatives\nVortexLattice.rotational_velocity\nVortexLattice.rotational_velocity_derivatives\nVortexLattice.get_surface_velocities!","category":"page"},{"location":"library/#VortexLattice.body_to_stability","page":"Library","title":"VortexLattice.body_to_stability","text":"body_to_stability(freestream)\n\nConstruct a rotation matrix from the body axis to the stability axis.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.body_to_wind","page":"Library","title":"VortexLattice.body_to_wind","text":"body_to_wind(freestream)\n\nConstruct a rotation matrix from the body axis to the wind axis\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.stability_to_body","page":"Library","title":"VortexLattice.stability_to_body","text":"stability_to_body(freestream)\n\nConstruct a rotation matrix from the stability axis to the body axis\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.stability_to_wind","page":"Library","title":"VortexLattice.stability_to_wind","text":"stability_to_wind(freestream)\n\nConstruct a rotation matrix from the stability axis to the wind axis\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.wind_to_body","page":"Library","title":"VortexLattice.wind_to_body","text":"wind_to_body(freestream)\n\nConstruct a rotation matrix from the wind axis to the body axis\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.wind_to_stability","page":"Library","title":"VortexLattice.wind_to_stability","text":"wind_to_stability(freestream)\n\nConstruct a rotation matrix from the wind axis to the stability axis\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.body_to_stability_alpha","page":"Library","title":"VortexLattice.body_to_stability_alpha","text":"body_to_stability_alpha(freestream)\n\nConstruct a rotation matrix from the body axis to the stability axis and its derivative with respect to alpha\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.body_to_wind_derivatives","page":"Library","title":"VortexLattice.body_to_wind_derivatives","text":"body_to_wind_derivatives(freestream)\n\nConstruct a rotation matrix from the body axis to the wind axis and its derivatives with respect to alpha and beta\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.stability_to_body_alpha","page":"Library","title":"VortexLattice.stability_to_body_alpha","text":"stability_to_body(freestream)\n\nConstruct a rotation matrix from the stability axis to the body axis and its derivative with respect to alpha\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.stability_to_wind_beta","page":"Library","title":"VortexLattice.stability_to_wind_beta","text":"stability_to_wind_beta(freestream)\n\nConstruct a rotation matrix from the stability axis to the wind axis and its derivative with respect to beta\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.wind_to_body_derivatives","page":"Library","title":"VortexLattice.wind_to_body_derivatives","text":"wind_to_body_derivatives(freestream)\n\nConstruct a rotation matrix from the wind axis to the body axis and its derivatives with respect to alpha and beta\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.wind_to_stability_beta","page":"Library","title":"VortexLattice.wind_to_stability_beta","text":"wind_to_stability_beta(freestream)\n\nConstruct a rotation matrix from the wind axis to the stability axis and its derivative with respect to beta\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.freestream_velocity","page":"Library","title":"VortexLattice.freestream_velocity","text":"freestream_velocity(freestream)\n\nComputes the freestream velocity\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.freestream_velocity_derivatives","page":"Library","title":"VortexLattice.freestream_velocity_derivatives","text":"freestream_velocity_derivatives(freestream)\n\nComputes the freestream velocity\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.rotational_velocity","page":"Library","title":"VortexLattice.rotational_velocity","text":"rotational_velocity(r, freestream, reference)\n\nCompute the velocity due to body rotations about the reference center\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.rotational_velocity_derivatives","page":"Library","title":"VortexLattice.rotational_velocity_derivatives","text":"rotational_velocity_derivatives(r, freestream, reference)\n\nCompute the velocity due to body rotations about the reference center and its derivatives with respect to (p, q, r)\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.get_surface_velocities!","page":"Library","title":"VortexLattice.get_surface_velocities!","text":"get_surface_velocities!(Vcp, Vh, Vv, Vte, current_surface, previous_surface, dt)\n\nCalculate the velocities experienced by the surface at the control points, horizontal bound vortex centers, vertical bound vortex centers and trailing edge vertices due to surface motion.\n\n\n\n\n\n","category":"function"},{"location":"library/#Circulation","page":"Library","title":"Circulation","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"VortexLattice.normal_velocity!\nVortexLattice.normal_velocity_derivatives!\nVortexLattice.circulation\nVortexLattice.circulation!\nVortexLattice.circulation_derivatives\nVortexLattice.circulation_derivatives!","category":"page"},{"location":"library/#VortexLattice.normal_velocity!","page":"Library","title":"VortexLattice.normal_velocity!","text":"normal_velocity!(w, surfaces, wakes, ref, fs; additional_velocity,\n    Vcp, symmetric, nwake, surface_id, wake_finite_core, trailing_vortices, xhat)\n\nCompute the downwash at the control points on surfaces due to the freestream velocity, rotational velocity, additional velocity field, surface motion, and induced velocity from the wake panels.\n\nThis forms the right hand side of the circulation linear system solve.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.normal_velocity_derivatives!","page":"Library","title":"VortexLattice.normal_velocity_derivatives!","text":"normal_velocity_derivatives!(w, dw, surfaces, wakes, ref, fs;\n    additional_velocity, Vcp, symmetric, nwake, surface_id,\n    wake_finite_core, trailing_vortices, xhat)\n\nCompute the downwash at the control points on surfaces due to the freestream velocity, rotational velocity, additional velocity field, surface motion, and induced velocity from the wake panels.  Also calculate its derivatives with respect to the freestream parameters.\n\nThis forms the right hand side of the circulation linear system solve (and its derivatives).\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.circulation","page":"Library","title":"VortexLattice.circulation","text":"circulation(AIC, w)\n\nSolve for the circulation distribution.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.circulation!","page":"Library","title":"VortexLattice.circulation!","text":"circulation!(Γ, AIC, w)\n\nPre-allocated version of circulation\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.circulation_derivatives","page":"Library","title":"VortexLattice.circulation_derivatives","text":"circulation_derivatives(AIC, w, dw)\n\nSolve for the circulation distribution and its derivatives with respect to the freestream parameters.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.circulation_derivatives!","page":"Library","title":"VortexLattice.circulation_derivatives!","text":"circulation_derivatives!(Γ, dΓ, AIC, w, dw)\n\nPre-allocated version of circulation_derivatives\n\n\n\n\n\n","category":"function"},{"location":"library/#Time-Domain-Analysis","page":"Library","title":"Time-Domain Analysis","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"VortexLattice.propagate_system!","category":"page"},{"location":"library/#VortexLattice.propagate_system!","page":"Library","title":"VortexLattice.propagate_system!","text":"propagate_system!(system, [surfaces, ] freestream, dt; kwargs...)\n\nPropagate the state variables in system forward one time step using the unsteady vortex lattice method system of equations.\n\nArguments\n\nsystem: Object of type system which contains the current system state\nsurfaces: Surface locations at the end of this time step. If omitted, surfaces are assumed to be stationary.\nfreestream: Freestream parameters corresponding to this time step.\ndt: Time increment\n\nKeyword Arguments\n\nadditional_velocity: Function which defines additional velocity as a  function of location.\nrepeated_points: Dictionary of the form Dict((isurf, i) => [(jsurf1, j1),  (jsurf2, j2)...] which defines repeated trailing edge points.  Trailing edge  point i on surface isurf is repeated on surface jsurf1 at point j1,  jsurf2 at point j2, and so forth. See repeated_trailing_edge_points\nnwake: Number of wake panels in the chordwise direction for each surface.\neta: Time step fraction used to define separation between trailing  edge and wake shedding location.  Typical values range from 0.2-0.3.\ncalculate_influence_matrix: Flag indicating whether the aerodynamic influence  coefficient matrix needs to be calculated. If argument surfaces is provided  the influence matrix will always be recalculated.\nnear_field_analysis: Flag indicating whether a near field analysis should be  performed to obtain panel velocities, circulation, and forces.\nderivatives: Flag indicating whether the derivatives with respect to the  freestream variables should be calculated.\n\n\n\n\n\n","category":"function"},{"location":"library/#Near-Field-Analysis","page":"Library","title":"Near-Field Analysis","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"VortexLattice.near_field_forces!\nVortexLattice.near_field_forces_derivatives!\nVortexLattice.body_forces(surfaces, properties, ref, fs, symmetric, frame)\nVortexLattice.body_forces_derivatives\nVortexLattice.body_to_frame","category":"page"},{"location":"library/#VortexLattice.near_field_forces!","page":"Library","title":"VortexLattice.near_field_forces!","text":"near_field_forces!(properties, surfaces, wakes, reference, freestream, Γ;\n    dΓdt, additional_velocity, Vh, Vv, symmetric, nwake, surface_id,\n    wake_finite_core, wake_shedding_locations, trailing_vortices, xhat)\n\nCalculate local panel forces in the body frame.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.near_field_forces_derivatives!","page":"Library","title":"VortexLattice.near_field_forces_derivatives!","text":"near_field_forces_derivatives!(properties, dproperties, surfaces, reference,\n    freestream, Γ, dΓ; dΓdt, additional_velocity, Vh, Vv, symmetric, nwake,\n    surface_id, wake_finite_core, wake_shedding_locations, trailing_vortices, xhat)\n\nVersion of near_field_forces! that also calculates the derivatives of the local panel forces with respect to the freestream variables.\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.body_forces-NTuple{6, Any}","page":"Library","title":"VortexLattice.body_forces","text":"body_forces(surfaces, properties, reference, freestream, symmetric; kwargs...)\n\nReturn the body force coefficients given the panel properties for surfaces\n\nNote that this function assumes that a near-field analysis has already been performed to obtain the panel forces.\n\nArguments:\n\nsurfaces: Collection of surfaces, where each surface is represented by a  matrix of surface panels (see SurfacePanel) of shape (nc, ns)  where nc is the number of chordwise panels and ns is the number of  spanwise panels\nproperties: Surface properties for each surface, where surface  properties for each surface are represented by a matrix of panel properties  (see PanelProperties) of shape (nc, ns) where nc is the number  of chordwise panels and ns is the number of spanwise panels\nreference: Reference parameters (see Reference)\nfreestream: Freestream parameters (see [Freestream]@ref)\nsymmetric: (required) Flag for each surface indicating whether a mirror image (across the X-Z plane) was used when calculating induced velocities\nframe: frame in which to return CF and CM, options are Body() (default), Stability(), and Wind()\n\n\n\n\n\n","category":"method"},{"location":"library/#VortexLattice.body_forces_derivatives","page":"Library","title":"VortexLattice.body_forces_derivatives","text":"body_forces_derivatives(system)\n\nReturn the body force coefficients for the system and their derivatives with respect to the freestream variables\n\nNote that this function assumes that a near-field analysis has already been performed to obtain the panel forces.\n\nArguments:\n\nsystem: Object of type System which holds system properties\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.body_to_frame","page":"Library","title":"VortexLattice.body_to_frame","text":"body_to_frame(CF, CM, reference, freestream, frame)\n\nTransform the coefficients CF and CM from the body frame to the frame specified in frame\n\n\n\n\n\n","category":"function"},{"location":"library/#Far-Field","page":"Library","title":"Far-Field","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"VortexLattice.TrefftzPanel\nVortexLattice.normal(panel::VortexLattice.TrefftzPanel)\nVortexLattice.trefftz_panels\nVortexLattice.trefftz_panel_induced_drag\nVortexLattice.vortex_induced_drag","category":"page"},{"location":"library/#VortexLattice.TrefftzPanel","page":"Library","title":"VortexLattice.TrefftzPanel","text":"TrefftzPanel{TF}\n\nPanel in the Trefftz plane.\n\n\n\n\n\n","category":"type"},{"location":"library/#VortexLattice.normal-Tuple{TrefftzPanel}","page":"Library","title":"VortexLattice.normal","text":"normal(panel::TrefftzPanel)\n\nReturn the normal vector of panel, including magnitude\n\n\n\n\n\n","category":"method"},{"location":"library/#VortexLattice.trefftz_panels","page":"Library","title":"VortexLattice.trefftz_panels","text":"trefftz_panels(surface[s], freestream, Γ)\n\nConstructs a set of panels for Trefftz plane calculations\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.trefftz_panel_induced_drag","page":"Library","title":"VortexLattice.trefftz_panel_induced_drag","text":"trefftz_panel_induced_drag(receiving::TrefftzPanel, sending::TrefftzPanel; kwargs...)\n\nInduced drag on receiving panel induced by sending panel.\n\nKeyword Arguments\n\nsymmetric: Flag indicating whether a mirror image of sending should be  used when calculating the induced drag\n\n\n\n\n\n","category":"function"},{"location":"library/#VortexLattice.vortex_induced_drag","page":"Library","title":"VortexLattice.vortex_induced_drag","text":"vortex_induced_drag(rj, Γj, ri, Γi, ni)\n\nReturn induced drag from vortex j induced on panel i\n\n\n\n\n\n","category":"function"},{"location":"library/#Visualization-2","page":"Library","title":"Visualization","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"VortexLattice.write_vtk!","category":"page"},{"location":"library/#VortexLattice.write_vtk!","page":"Library","title":"VortexLattice.write_vtk!","text":"write_vtk!(vtmfile, surface, [surface_properties]; kwargs...)\n\nWrites geometry to Paraview files for visualization.\n\nArguments\n\nvtmfile: Multiblock file handle\nsurface: Matrix of surface panels (see SurfacePanel) of shape  (nc, ns) where nc is the number of chordwise panels and ns is the number  of spanwise panels\nsurface_properties: (optional) Matrix of panel properties for each non-wake panel  where each element of the matrix is of type PanelProperties.\n\nKeyword Arguments:\n\nsymmetric: (required if properties is provided) Flag indicating whether a  mirror image (across the X-Z plane) was used when calculating induced velocities.\ntrailing_vortices = true: Flag indicating whether the model uses trailing vortices\nxhat = [1, 0, 0]: Direction in which trailing vortices extend if used\nwake_length = 10: Distance to extend trailing vortices\nwake_circulation = zeros(size(surfaces, 2)): Contribution to the trailing  edge circulation from the wake attached to this surface\nmetadata = Dict(): Dictionary of metadata to include in generated files\n\n\n\n\n\nwrite_vtk!(vtmfile, wake; kwargs...)\n\nWrites geometry to Paraview files for visualization.\n\nArguments\n\nvtmfile: Paraview file handle\nwake: Matrix of wake panels (see WakePanel) of shape (nw, ns)  where nw is the number of chordwise wake panels and ns is the number of  spanwise panels\n\nKeyword Arguments:\n\nsymmetric: (required) Flag indicating whether a mirror image (across the  X-Z plane) was used when calculating induced velocities.\ntrailing_vortices = false: Flag indicating whether the model uses trailing vortices\nxhat = [1, 0, 0]: Direction in which trailing vortices extend if used\nwake_length = 10: Distance to extend trailing vortices\nsurface_circulation = zeros(size(wake, 2)): Contribution to the leading edge  circulation from the surface attached to this wake.\nmetadata = Dict(): Dictionary of metadata to include in generated files\n\n\n\n\n\n","category":"function"},{"location":"library/#Index","page":"Library","title":"Index","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"These examples show how to use VortexLattice for various geometries, flow conditions, and analyses.  Many of these examples also provide a verification for the implementation of the vortex lattice method in this package.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pages = [\"examples.md\"]\nDepth = 3","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# this is placed here to pre-install matplotlib so the documentation doesn't get cluttered with the installation print statements.\nusing Plots\npyplot()","category":"page"},{"location":"examples/#Steady-State-Analysis-of-a-Wing","page":"Examples","title":"Steady State Analysis of a Wing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to calculate aerodynamic coefficients and stability derivatives for a symmetric planar wing.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using VortexLattice\n\n# geometry (right half of the wing)\nxle = [0.0, 0.4]\nyle = [0.0, 7.5]\nzle = [0.0, 0.0]\nchord = [2.2, 1.8]\ntheta = [2.0*pi/180, 2.0*pi/180]\nphi = [0.0, 0.0]\nfc = fill((xc) -> 0, 2) # camberline function for each section\n\n# discretization parameters\nns = 12\nnc = 6\nspacing_s = Uniform()\nspacing_c = Uniform()\n\n# reference parameters\nSref = 30.0\ncref = 2.0\nbref = 15.0\nrref = [0.50, 0.0, 0.0]\nVinf = 1.0\nref = Reference(Sref, cref, bref, rref, Vinf)\n\n# freestream parameters\nalpha = 1.0*pi/180\nbeta = 0.0\nOmega = [0.0; 0.0; 0.0]\nfs = Freestream(Vinf, alpha, beta, Omega)\n\n# construct surface\ngrid, surface = wing_to_surface_panels(xle, yle, zle, chord, theta, phi, ns, nc;\n    fc = fc, spacing_s=spacing_s, spacing_c=spacing_c)\n\n# create vector containing all surfaces\nsurfaces = [surface]\n\n# we can use symmetry since the geometry and flow conditions are symmetric about the X-Z axis\nsymmetric = true\n\n# perform steady state analysis\nsystem = steady_analysis(surfaces, ref, fs; symmetric=symmetric)\n\n# retrieve near-field forces\nCF, CM = body_forces(system; frame=Wind())\n\n# perform far-field analysis\nCDiff = far_field_drag(system)\n\nCD, CY, CL = CF\nCl, Cm, Cn = CM\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The aerodynamic coefficients predicted by VortexLattice are nearly identical to those predicted by AVL.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using PrettyTables # hide\nusing Markdown # hide\n\nCD_avl = 0.00247 # hide\nCL_avl = 0.24454 # hide\nCm_avl = -0.02091 # hide\nCDiff_avl = 0.00248 # hide\n\ntable = [  # hide\n\"``C_L``\" CL CL_avl CL-CL_avl;  # hide\n\"``C_{Di}`` (nearfield)\" CD CD_avl CD-CD_avl;  # hide\n\"``C_{Di}`` (farfield)\" CDiff CDiff_avl CDiff-CDiff_avl;  # hide\n\"``C_M``\" Cm Cm_avl Cm-Cm_avl  # hide\n]  # hide\nheader = [\"Coefficient\", \"VortexLattice\", \"AVL\", \"Difference\"]  # hide\n\nstr = pretty_table(String, table; #hide\n    backend=Val(:text), # hide\n    header=(header,), # hide\n    tf = tf_markdown, # hide\n    alignment=[:l, :r, :r, :r], # hide\n    formatters = (ft_printf(\"%0.5f\", [2,3]), ft_printf(\"%0.1e\", 4))) # hide\n\nMarkdown.parse(str) # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can also generate files to visualize the results in Paraview using the function write_vtk.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"properties = get_surface_properties(system)\n\nwrite_vtk(\"symmetric-planar-wing\", surfaces, properties; symmetric)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For asymmetric flow conditions and/or to obtain accurate asymmetric stability derivatives we can use the keyword argument mirror when constructing the geometry to reflect the geometry across the X-Z plane prior to the analysis.  We also set the symmetric flag to false since we are no longer using symmetry in the analysis.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\n# construct geometry with mirror image\ngrid, surface = wing_to_surface_panels(xle, yle, zle, chord, theta, phi, ns, nc;\n    fc=fc, spacing_s=spacing_s, spacing_c=spacing_c, mirror=true)\n\n# symmetry is not used in the analysis\nsymmetric = false\n\n# create vector containing all surfaces\nsurfaces = [surface]\n\n# perform steady state analysis\nsystem = steady_analysis(surfaces, ref, fs; symmetric=symmetric)\n\n# retrieve near-field forces\nCF, CM = body_forces(system; frame=Wind())\n\n# perform far-field analysis\nCDiff = far_field_drag(system)\n\nCD, CY, CL = CF\nCl, Cm, Cn = CM\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Once again, the aerodynamic coefficients predicted by VortexLattice are nearly identical to those predicted by AVL.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using PrettyTables # hide\nusing Markdown # hide\n\nCD_avl = 0.00247 # hide\nCL_avl = 0.24454 # hide\nCm_avl = -0.02091 # hide\nCDiff_avl = 0.00248 # hide\n\ntable = [ # hide\n\"``C_L``\" CL CL_avl CL-CL_avl; # hide\n\"``C_{Di}`` (nearfield)\" CD CD_avl CD-CD_avl; # hide\n\"``C_{Di}`` (farfield)\" CDiff CDiff_avl CDiff-CDiff_avl; # hide\n\"``C_M``\" Cm Cm_avl Cm-Cm_avl # hide\n] # hide\nheader = [\"Coefficient\", \"VortexLattice\", \"AVL\", \"Difference\"] # hide\n\nstr = pretty_table(String, table; # hide\n    backend=Val(:text), # hide\n    header=(header,), # hide\n    tf = tf_markdown, # hide\n    alignment=[:l, :r, :r, :r], # hide\n    formatters = (ft_printf(\"%0.5f\", [2,3]), ft_printf(\"%0.1e\", 4))) # hide\n\nMarkdown.parse(str) # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The stability derivatives are also very close to those predicted by AVL.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\ndCF, dCM = stability_derivatives(system)\n\nCDa, CYa, CLa = dCF.alpha\nCla, Cma, Cna = dCM.alpha\nCDb, CYb, CLb = dCF.beta\nClb, Cmb, Cnb = dCM.beta\nCDp, CYp, CLp = dCF.p\nClp, Cmp, Cnp = dCM.p\nCDq, CYq, CLq = dCF.q\nClq, Cmq, Cnq = dCM.q\nCDr, CYr, CLr = dCF.r\nClr, Cmr, Cnr = dCM.r\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using PrettyTables # hide\nusing Markdown # hide\n\nCLa_avl =   4.663214 # hide\nCLb_avl =   0.0 # hide\nCYa_avl =   0.0 # hide\nCYb_avl =  -0.000002 # hide\nCla_avl =   0.0 # hide\nClb_avl =  -0.025435 # hide\nCma_avl =  -0.397758 # hide\nCmb_avl =   0.0 # hide\nCna_avl =   0.0 # hide\nCnb_avl =   0.000452 # hide\nCLp_avl =   0.0 # hide\nCLq_avl =   5.649411 # hide\nCLr_avl =   0.0 # hide\nCYp_avl =   0.049063 # hide\nCYq_avl =   0.0 # hide\nCYr_avl =  -0.000828 # hide\nClp_avl =  -0.524750 # hide\nClq_avl =   0.0 # hide\nClr_avl =   0.064456 # hide\nCmp_avl =   0.0 # hide\nCmq_avl =  -1.270212 # hide\nCmr_avl =   0.0 # hide\nCnp_avl =  -0.019175 # hide\nCnq_avl =   0.0 # hide\nCnr_avl =  -0.000931 # hide\n\ntable = [ # hide\n\"``C_{La}``\" CLa CLa_avl CLa-CLa_avl; # hide\n\"``C_{Lb}``\" CLb CLb_avl CLb-CLb_avl; # hide\n\"``C_{Ya}``\" CYa CYa_avl CYa-CYa_avl; # hide\n\"``C_{Yb}``\" CYb CYb_avl CYb-CYb_avl; # hide\n\"``C_{la}``\" Cla Cla_avl Cla-Cla_avl; # hide\n\"``C_{lb}``\" Clb Clb_avl Clb-Clb_avl; # hide\n\"``C_{ma}``\" Cma Cma_avl Cma-Cma_avl; # hide\n\"``C_{mb}``\" Cmb Cmb_avl Cmb-Cmb_avl; # hide\n\"``C_{na}``\" Cna Cna_avl Cna-Cna_avl; # hide\n\"``C_{nb}``\" Cnb Cnb_avl Cnb-Cnb_avl; # hide\n\"``C_{Lp}``\" CLp CLp_avl CLp-CLp_avl; # hide\n\"``C_{Lq}``\" CLq CLq_avl CLq-CLq_avl; # hide\n\"``C_{Lr}``\" CLr CLr_avl CLr-CLr_avl; # hide\n\"``C_{Yp}``\" CYp CYp_avl CYp-CYp_avl; # hide\n\"``C_{Yq}``\" CYq CYq_avl CYq-CYq_avl; # hide\n\"``C_{Yr}``\" CYr CYr_avl CYr-CYr_avl; # hide\n\"``C_{lp}``\" Clp Clp_avl Clp-Clp_avl; # hide\n\"``C_{lq}``\" Clq Clq_avl Clq-Clq_avl; # hide\n\"``C_{lr}``\" Clr Clr_avl Clr-Clr_avl; # hide\n\"``C_{mp}``\" Cmp Cmp_avl Cmp-Cmp_avl; # hide\n\"``C_{mq}``\" Cmq Cmq_avl Cmq-Cmq_avl; # hide\n\"``C_{mr}``\" Cmr Cmr_avl Cmr-Cmr_avl; # hide\n\"``C_{np}``\" Cnp Cnp_avl Cnp-Cnp_avl; # hide\n\"``C_{nq}``\" Cnq Cnq_avl Cnq-Cnq_avl; # hide\n\"``C_{nr}``\" Cnr Cnr_avl Cnr-Cnr_avl; # hide\n] # hide\nheader = [\"Coefficient\", \"VortexLattice\", \"AVL\", \"Difference\"] # hide\n\nstr = pretty_table(String, table; # hide\n    backend=Val(:text), # hide\n    header=(header,), # hide\n    tf = tf_markdown, # hide\n    alignment=[:l, :r, :r, :r], # hide\n    formatters = (ft_printf(\"%0.5f\", [2,3]), ft_printf(\"%0.1e\", 4))) # hide\n\nMarkdown.parse(str) # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Visualizing the geometry now shows the circulation distribution across the entire wing.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"properties = get_surface_properties(system)\n\nwrite_vtk(\"mirrored-planar-wing\", surfaces, properties; symmetric)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Steady-State-Analysis-of-a-Wing-with-Dihedral","page":"Examples","title":"Steady State Analysis of a Wing with Dihedral","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to calculate aerodynamic coefficients and stability derivatives for a simple wing with dihedral.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using VortexLattice\n\nxle = [0.0, 0.4]\nyle = [0.0, 7.5]\nzle = [0.0, 3.0]\nchord = [2.2, 1.8]\ntheta = [2.0*pi/180, 2.0*pi/180]\nphi = [0.0, 0.0]\nfc = fill((xc) -> 0, 2) #camberline function for each section\n\nns = 12\nnc = 6\nspacing_s = Uniform()\nspacing_c = Uniform()\nmirror = false\nsymmetric = true\n\nSref = 30.0\ncref = 2.0\nbref = 15.0\nrref = [0.50, 0.0, 0.0]\nVinf = 1.0\nref = Reference(Sref, cref, bref, rref, Vinf)\n\nalpha = 1.0*pi/180\nbeta = 0.0\nOmega = [0.0; 0.0; 0.0]\nfs = Freestream(Vinf, alpha, beta, Omega)\n\n# declare symmetry\nsymmetric = true\n\n# construct surface\ngrid, surface = wing_to_surface_panels(xle, yle, zle, chord, theta, phi, ns, nc;\n    fc = fc, spacing_s=spacing_s, spacing_c=spacing_c)\n\n# create vector containing all surfaces\nsurfaces = [surface]\n\n# perform steady state analysis\nsystem = steady_analysis(surfaces, ref, fs; symmetric=symmetric)\n\n# retrieve near-field forces\nCF, CM = body_forces(system; frame=Wind())\n\n# perform far-field analysis\nCDiff = far_field_drag(system)\n\nCD, CY, CL = CF\nCl, Cm, Cn = CM\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The results predicted by VortexLattice are close to those predicted by AVL, with the difference primarily explained by the manner in which the normal vector is defined in VortexLattice and AVL, respectively.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using PrettyTables # hide\nusing Markdown # hide\n\nCD_avl = 0.00248 # hide\nCL_avl = 0.24808 # hide\nCm_avl = -0.02250 # hide\nCDiff_avl = 0.0024671 # hide\n\ntable = [ # hide\n\"``C_L``\" CL CL_avl CL-CL_avl; # hide\n\"``C_{Di}`` (nearfield)\" CD CD_avl CD-CD_avl; # hide\n\"``C_{Di}`` (farfield)\" CDiff CDiff_avl CDiff-CDiff_avl; # hide\n\"``C_M``\" Cm Cm_avl Cm-Cm_avl # hide\n] # hide\nheader = [\"Coefficient\", \"VortexLattice\", \"AVL\", \"Difference\"] # hide\n\nstr = pretty_table(String, table; # hide\n    backend=Val(:text), # hide\n    header=(header,), # hide\n    tf = tf_markdown, # hide\n    alignment=[:l, :r, :r, :r], # hide\n    formatters = (ft_printf(\"%0.5f\", [2,3]), ft_printf(\"%0.1e\", 4))) # hide\n\nMarkdown.parse(str) # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If we set the normal vectors in VortexLattice equal to those used in AVL, the results are even closer, though not necessarily more accurate.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing LinearAlgebra\n\n# function to construct a normal vector the way AVL does\n#  - `ds` is a line representing the leading edge\n#  - `theta` is the incidence angle, taken as a rotation (+ by RH rule) about\n#        the surface's spanwise axis projected onto the Y-Z plane.\nfunction avl_normal_vector(ds, theta)\n\n    st, ct = sincos(theta)\n\n    # bound vortex vector\n    bhat = ds/norm(ds)\n\n    # chordwise strip normal vector\n    shat = [0, -ds[3], ds[2]]/sqrt(ds[2]^2+ds[3]^2)\n\n    # camberline vector\n    chat = [ct, -st*shat[2], -st*shat[3]]\n\n    # normal vector perpindicular to camberline and bound vortex for entire chordwise strip\n    ncp = cross(chat, ds)\n    return ncp / norm(ncp) # normal vector used by AVL\nend\n\n# new normal vector\nncp = avl_normal_vector([xle[2]-xle[1], yle[2]-yle[1], zle[2]-zle[1]], 2.0*pi/180)\n\n# overwrite normal vector for each panel\nfor i = 1:length(surface)\n    surface[i] = set_normal(surface[i], ncp)\nend\n\n# create vector containing all surfaces\nsurfaces = [surface]\n\n# perform steady state analysis\nsystem = steady_analysis(surfaces, ref, fs; symmetric=symmetric)\n\n# retrieve near-field forces\nCF, CM = body_forces(system; frame=Wind())\n\n# perform far-field analysis\nCDiff = far_field_drag(system)\n\nCD, CY, CL = CF\nCl, Cm, Cn = CM\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using PrettyTables # hide\nusing Markdown # hide\n\nCD_avl = 0.00248 # hide\nCL_avl = 0.24808 # hide\nCm_avl = -0.02250 # hide\nCDiff_avl = 0.0024671 # hide\n\ntable = [ # hide\n\"``C_L``\" CL CL_avl CL-CL_avl; # hide\n\"``C_{Di}`` (nearfield)\" CD CD_avl CD-CD_avl; # hide\n\"``C_{Di}`` (farfield)\" CDiff CDiff_avl CDiff-CDiff_avl; # hide\n\"``C_M``\" Cm Cm_avl Cm-Cm_avl # hide\n] # hide\nheader = [\"Coefficient\", \"VortexLattice\", \"AVL\", \"Difference\"] # hide\n\nstr = pretty_table(String, table; # hide\n    backend=Val(:text), # hide\n    header=(header,), # hide\n    tf = tf_markdown, # hide\n    alignment=[:l, :r, :r, :r], # hide\n    formatters = (ft_printf(\"%0.5f\", [2,3]), ft_printf(\"%0.1e\", 4))) # hide\n\nMarkdown.parse(str) # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"properties = get_surface_properties(system)\n\nwrite_vtk(\"wing-with-dihedral\", surfaces, properties; symmetric)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Steady-State-Analysis-of-a-Wing-and-Tail","page":"Examples","title":"Steady State Analysis of a Wing and Tail","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to calculate aerodynamic coefficients and stability derivatives for multiple lifting surfaces.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using VortexLattice\n\n# wing\nxle = [0.0, 0.2]\nyle = [0.0, 5.0]\nzle = [0.0, 1.0]\nchord = [1.0, 0.6]\ntheta = [2.0*pi/180, 2.0*pi/180]\nphi = [0.0, 0.0]\nfc = fill((xc) -> 0, 2) # camberline function for each section\nns = 12\nnc = 6\nspacing_s = Uniform()\nspacing_c = Uniform()\nmirror = false\n\n# horizontal stabilizer\nxle_h = [0.0, 0.14]\nyle_h = [0.0, 1.25]\nzle_h = [0.0, 0.0]\nchord_h = [0.7, 0.42]\ntheta_h = [0.0, 0.0]\nphi_h = [0.0, 0.0]\nfc_h = fill((xc) -> 0, 2) #camberline function for each section\nns_h = 6\nnc_h = 3\nspacing_s_h = Uniform()\nspacing_c_h = Uniform()\nmirror_h = false\n\n# vertical stabilizer\nxle_v = [0.0, 0.14]\nyle_v = [0.0, 0.0]\nzle_v = [0.0, 1.0]\nchord_v = [0.7, 0.42]\ntheta_v = [0.0, 0.0]\nphi_v = [0.0, 0.0]\nfc_v = fill((xc) -> 0, 2) #camberline function for each section\nns_v = 5\nnc_v = 3\nspacing_s_v = Uniform()\nspacing_c_v = Uniform()\nmirror_v = false\n\nSref = 9.0\ncref = 0.9\nbref = 10.0\nrref = [0.5, 0.0, 0.0]\nVinf = 1.0\nref = Reference(Sref, cref, bref, rref, Vinf)\n\nalpha = 5.0*pi/180\nbeta = 0.0\nOmega = [0.0; 0.0; 0.0]\nfs = Freestream(Vinf, alpha, beta, Omega)\n\nsymmetric = [true, true, false]\n\n# generate surface panels for wing\nwgrid, wing = wing_to_surface_panels(xle, yle, zle, chord, theta, phi, ns, nc;\n    mirror=mirror, fc = fc, spacing_s=spacing_s, spacing_c=spacing_c)\n\n# generate surface panels for horizontal tail\nhgrid, htail = wing_to_surface_panels(xle_h, yle_h, zle_h, chord_h, theta_h, phi_h, ns_h, nc_h;\n    mirror=mirror_h, fc=fc_h, spacing_s=spacing_s_h, spacing_c=spacing_c_h)\ntranslate!(hgrid, [4.0, 0.0, 0.0])\ntranslate!(htail, [4.0, 0.0, 0.0])\n\n# generate surface panels for vertical tail\nvgrid, vtail = wing_to_surface_panels(xle_v, yle_v, zle_v, chord_v, theta_v, phi_v, ns_v, nc_v;\n    mirror=mirror_v, fc=fc_v, spacing_s=spacing_s_v, spacing_c=spacing_c_v)\ntranslate!(vgrid, [4.0, 0.0, 0.0])\ntranslate!(vtail, [4.0, 0.0, 0.0])\n\ngrids = [wgrid, hgrid, vgrid]\nsurfaces = [wing, htail, vtail]\nsurface_id = [1, 2, 3]\n\nsystem = steady_analysis(surfaces, ref, fs; symmetric=symmetric, surface_id=surface_id)\n\nCF, CM = body_forces(system; frame=Wind())\n\nCDiff = far_field_drag(system)\n\nCD, CY, CL = CF\nCl, Cm, Cn = CM\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The results predicted by VortexLattice are close to those predicted by AVL (with the finite core model disabled in AVL), with the difference primarily explained by the manner in which the normal vector is defined in VortexLattice and AVL, respectively.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using PrettyTables # hide\nusing Markdown # hide\n\nCD_avl = 0.01060 # hide\nCL_avl = 0.60478 # hide\nCm_avl = -0.02700 # hide\nCDiff_avl = 0.0104282 # hide\n\ntable = [ # hide\n\"``C_L``\" CL CL_avl CL-CL_avl; # hide\n\"``C_{Di}`` (nearfield)\" CD CD_avl CD-CD_avl; # hide\n\"``C_{Di}`` (farfield)\" CDiff CDiff_avl CDiff-CDiff_avl; # hide\n\"``C_M``\" Cm Cm_avl Cm-Cm_avl # hide\n] # hide\nheader = [\"Coefficient\", \"VortexLattice\", \"AVL\", \"Difference\"] # hide\n\nstr = pretty_table(String, table; # hide\n    backend=Val(:text), # hide\n    header=(header,), # hide\n    tf = tf_markdown, # hide\n    alignment=[:l, :r, :r, :r], # hide\n    formatters = (ft_printf(\"%0.5f\", [2,3]), ft_printf(\"%0.1e\", 4))) # hide\n\nMarkdown.parse(str) # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If we set the normal vectors in VortexLattice equal to those used in AVL, the results are closer, though not necessarily more accurate.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing LinearAlgebra\n\n# function to construct a normal vector the way AVL does\n#  - `ds` is a line representing the leading edge\n#  - `theta` is the incidence angle, taken as a rotation (+ by RH rule) about\n#        the surface's spanwise axis projected onto the Y-Z plane.\nfunction avl_normal_vector(ds, theta)\n\n    st, ct = sincos(theta)\n\n    # bound vortex vector\n    bhat = ds/norm(ds)\n\n    # chordwise strip normal vector\n    shat = [0, -ds[3], ds[2]]/sqrt(ds[2]^2+ds[3]^2)\n\n    # camberline vector\n    chat = [ct, -st*shat[2], -st*shat[3]]\n\n    # normal vector perpindicular to camberline and bound vortex for entire chordwise strip\n    ncp = cross(chat, ds)\n    return ncp / norm(ncp) # normal vector used by AVL\nend\n\n# new normal vector for the wing\nncp = avl_normal_vector([xle[2]-xle[1], yle[2]-yle[1], zle[2]-zle[1]], 2.0*pi/180)\n\n# overwrite normal vector for each wing panel\nfor i = 1:length(wing)\n    wing[i] = set_normal(wing[i], ncp)\nend\nsurfaces[1] = wing\n\n# perform steady state analysis\nsystem = steady_analysis(surfaces, ref, fs; symmetric=symmetric)\n\n# retrieve near-field forces\nCF, CM = body_forces(system; frame=Wind())\n\n# perform far-field analysis\nCDiff = far_field_drag(system)\n\nCD, CY, CL = CF\nCl, Cm, Cn = CM\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using PrettyTables # hide\nusing Markdown # hide\n\nCD_avl = 0.01060 # hide\nCL_avl = 0.60478 # hide\nCm_avl = -0.02700 # hide\nCDiff_avl = 0.0104282 # hide\n\ntable = [ # hide\n\"``C_L``\" CL CL_avl CL-CL_avl; # hide\n\"``C_{Di}`` (nearfield)\" CD CD_avl CD-CD_avl; # hide\n\"``C_{Di}`` (farfield)\" CDiff CDiff_avl CDiff-CDiff_avl; # hide\n\"``C_M``\" Cm Cm_avl Cm-Cm_avl # hide\n] # hide\nheader = [\"Coefficient\", \"VortexLattice\", \"AVL\", \"Difference\"] # hide\n\nstr = pretty_table(String, table; # hide\n    backend=Val(:text), # hide\n    header=(header,), # hide\n    tf = tf_markdown, # hide\n    alignment=[:l, :r, :r, :r], # hide\n    formatters = (ft_printf(\"%0.5f\", [2,3]), ft_printf(\"%0.1e\", 4))) # hide\n\nMarkdown.parse(str) # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To achieve a theoretically identical setup as AVL we can place all our panels in the X-Y plane and then set the normal vector manually to match the actual lifting geometry.  In our case this involves removing the small amount of twist on the wing when creating the wing surface panels.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using VortexLattice\n\n# wing\nxle = [0.0, 0.2]\nyle = [0.0, 5.0]\nzle = [0.0, 1.0]\nchord = [1.0, 0.6]\ntheta = [0.0, 0.0]\nphi = [0.0, 0.0]\nfc = fill((xc) -> 0, 2) # camberline function for each section\nns = 12\nnc = 6\nspacing_s = Uniform()\nspacing_c = Uniform()\nmirror = false\n\n# horizontal stabilizer\nxle_h = [0.0, 0.14]\nyle_h = [0.0, 1.25]\nzle_h = [0.0, 0.0]\nchord_h = [0.7, 0.42]\ntheta_h = [0.0, 0.0]\nphi_h = [0.0, 0.0]\nfc_h = fill((xc) -> 0, 2) # camberline function for each section\nns_h = 6\nnc_h = 3\nspacing_s_h = Uniform()\nspacing_c_h = Uniform()\nmirror_h = false\n\n# vertical stabilizer\nxle_v = [0.0, 0.14]\nyle_v = [0.0, 0.0]\nzle_v = [0.0, 1.0]\nchord_v = [0.7, 0.42]\ntheta_v = [0.0, 0.0]\nphi_v = [0.0, 0.0]\nfc_v = fill((xc) -> 0, 2) # camberline function for each section\nns_v = 5\nnc_v = 3\nspacing_s_v = Uniform()\nspacing_c_v = Uniform()\nmirror_v = false\n\nSref = 9.0\ncref = 0.9\nbref = 10.0\nrref = [0.5, 0.0, 0.0]\nVinf = 1.0\nref = Reference(Sref, cref, bref, rref, Vinf)\n\nalpha = 5.0*pi/180\nbeta = 0.0\nOmega = [0.0; 0.0; 0.0]\nfs = Freestream(Vinf, alpha, beta, Omega)\n\nsymmetric = [true, true, false]\n\n# generate surface panels for wing\nwgrid, wing = wing_to_surface_panels(xle, yle, zle, chord, theta, phi, ns, nc;\n    mirror=mirror, fc=fc, spacing_s=spacing_s, spacing_c=spacing_c)\n\n# generate surface panels for horizontal tail\nhgrid, htail = wing_to_surface_panels(xle_h, yle_h, zle_h, chord_h, theta_h, phi_h, ns_h, nc_h;\n    mirror=mirror_h, fc=fc_h, spacing_s=spacing_s_h, spacing_c=spacing_c_h)\ntranslate!(hgrid, [4.0, 0.0, 0.0])\ntranslate!(htail, [4.0, 0.0, 0.0])\n\n# generate surface panels for vertical tail\nvgrid, vtail = wing_to_surface_panels(xle_v, yle_v, zle_v, chord_v, theta_v, phi_v, ns_v, nc_v;\n    mirror=mirror_v, fc=fc_v, spacing_s=spacing_s_v, spacing_c=spacing_c_v)\ntranslate!(vgrid, [4.0, 0.0, 0.0])\ntranslate!(vtail, [4.0, 0.0, 0.0])\n\n# now set normal vectors manually\nncp = avl_normal_vector([xle[2]-xle[1], yle[2]-yle[1], zle[2]-zle[1]], 2.0*pi/180)\n\n# overwrite normal vector for each wing panel\nfor i = 1:length(wing)\n    wing[i] = set_normal(wing[i], ncp)\nend\n\ngrids = [wgrid, hgrid, vgrid]\nsurfaces = [wing, htail, vtail]\nsurface_id = [1, 2, 3]\n\nsystem = steady_analysis(surfaces, ref, fs; symmetric=symmetric, surface_id=surface_id)\n\nCF, CM = body_forces(system; frame=Stability())\n\nCDiff = far_field_drag(system)\n\nCD, CY, CL = CF\nCl, Cm, Cn = CM\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The resulting aerodynamic coefficients now match very closely with AVL.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using PrettyTables # hide\nusing Markdown # hide\n\nCD_avl = 0.01060 # hide\nCL_avl = 0.60478 # hide\nCm_avl = -0.02700 # hide\nCDiff_avl = 0.0104282 # hide\n\ntable = [ # hide\n\"``C_L``\" CL CL_avl CL-CL_avl; # hide\n\"``C_{Di}`` (nearfield)\" CD CD_avl CD-CD_avl; # hide\n\"``C_{Di}`` (farfield)\" CDiff CDiff_avl CDiff-CDiff_avl; # hide\n\"``C_M``\" Cm Cm_avl Cm-Cm_avl # hide\n] # hide\nheader = [\"Coefficient\", \"VortexLattice\", \"AVL\", \"Difference\"] # hide\n\nstr = pretty_table(String, table; # hide\n    backend=Val(:text), # hide\n    header=(header,), # hide\n    tf = tf_markdown, # hide\n    alignment=[:l, :r, :r, :r], # hide\n    formatters = (ft_printf(\"%0.5f\", [2,3]), ft_printf(\"%0.1e\", 4))) # hide\n\nMarkdown.parse(str) # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"By comparing these results with previous results we can see exactly how much restricting surface panels in the X-Y plane changes the results from the vortex lattice method.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"properties = get_surface_properties(system)\n\nwrite_vtk(\"wing-tail\", surfaces, properties; symmetric)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Sudden-Acceleration-of-a-Rectangular-Wing-into-a-Constant-Speed-Forward-Flight","page":"Examples","title":"Sudden Acceleration of a Rectangular Wing into a Constant-Speed Forward Flight","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to predict the transient forces and moments on a rectangular wing when suddenly accelerated into forward flight at a five degree angle.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Katz and Plotkin: Figures 13.34 and 13.35\n# AR = [4, 8, 12, 20, ∞]\n# Vinf*Δt/c = 1/16\n# α = 5°\n\nusing VortexLattice\n\nAR = [4, 8, 12, 20, 1e3] # last aspect ratio is essentially infinite\n\nsystem = Vector{Any}(undef, length(AR))\nsurface_history = Vector{Any}(undef, length(AR))\nproperty_history = Vector{Any}(undef, length(AR))\nwake_history = Vector{Any}(undef, length(AR))\nCF = Vector{Vector{Vector{Float64}}}(undef, length(AR))\nCM = Vector{Vector{Vector{Float64}}}(undef, length(AR))\n\n# non-dimensional time (t*Vinf/c)\nt = range(0.0, 10.0, step=1/16)\n\n# chord length\nc = 1\n\n# time step\ndt = [t[i+1]-t[i] for i = 1:length(t)-1]\n\nfor i = 1:length(AR)\n\n    # span length\n    b = AR[i]*c\n\n    # planform area\n    S = b*c\n\n    # geometry\n    xle = [0.0, 0.0]\n    yle = [-b/2, b/2]\n    zle = [0.0, 0.0]\n    chord = [c, c]\n    theta = [0.0, 0.0]\n    phi = [0.0, 0.0]\n    fc = fill((xc) -> 0, 2) # camberline function for each section\n    ns = 13\n    nc = 4\n    spacing_s = Uniform()\n    spacing_c = Uniform()\n    mirror = false\n    symmetric = false\n\n    # reference parameters\n    cref = c\n    bref = b\n    Sref = S\n    rref = [0.0, 0.0, 0.0]\n    Vinf = 1.0\n    ref = Reference(Sref, cref, bref, rref, Vinf)\n\n    # freestream parameters\n    alpha = 5.0*pi/180\n    beta = 0.0\n    Omega = [0.0; 0.0; 0.0]\n    fs = Freestream(Vinf, alpha, beta, Omega)\n\n    # create vortex rings\n    grid, surface = wing_to_surface_panels(xle, yle, zle, chord, theta, phi, ns, nc;\n        mirror=mirror, fc=fc, spacing_s=spacing_s, spacing_c=spacing_c)\n\n    # create vector containing surfaces\n    surfaces = [surface]\n\n    # run analysis\n    system[i], surface_history[i], property_history[i], wake_history[i] =\n        unsteady_analysis(surfaces, ref, fs, dt; symmetric, wake_finite_core = false)\n\n    # extract forces at each time step\n    CF[i], CM[i] = body_forces_history(system[i], surface_history[i],\n        property_history[i]; frame=Wind())\n\nend\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can visualize the solution using the write_vtk function.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"write_vtk(\"acceleration-AR4\", surface_history[1], property_history[1],\n    wake_history[1], dt; symmetric=false)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The transient lift and drag coefficients are similar to those shown in Figures 13.34 and 13.35 of Low-Speed Aerodynamics by Katz and Plotkin.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\n\n# lift coefficient plot\nplot(\n    xlim = (0.0, 10.0),\n    xticks = 0.0:1.0:10.0,\n    xlabel = \"\\$ \\\\frac{U_\\\\infty t}{c} \\$\",\n    ylim = (0.0, 0.55),\n    yticks = 0.0:0.1:0.5,\n    ylabel = \"\\$ C_{L} \\$\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nfor i = 1:length(AR)\n    CL = [CF[i][j][3] for j = 1:length(CF[i])]\n    plot!(t[2:end], CL, label=\"AR = $(AR[i])\")\nend\n\nplot!(show=true)\n\nsavefig(\"rectangular-wing-sudden-acceleration-cl.svg\") # hide\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# drag coefficient plot\nplot(\n    xlim = (0.0, 10.0),\n    xticks = 0.0:1.0:10.0,\n    xlabel = \"\\$ \\\\frac{U_\\\\infty t}{c} \\$\",\n    ylim = (0.0, 0.030),\n    yticks = 0.0:0.005:0.03,\n    ylabel = \"\\$ C_{D} \\$\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nfor i = 1:length(AR)\n    CD = [CF[i][j][1] for j = 1:length(CF[i])]\n    plot!(t[2:end], CD, label=\"AR = $(AR[i])\")\nend\n\nplot!(show=true)\n\nsavefig(\"rectangular-wing-sudden-acceleration-cd.svg\") # hide\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We modeled the problem in the body-fixed reference frame (which for this problem is more straightforward), but we could have also modeled the problem in the global reference frame.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Katz and Plotkin: Figures 13.34 and 13.35\n# AR = [4, 8, 12, 20, ∞]\n# Vinf*Δt/c = 1/16\n# α = 5°\n\nusing VortexLattice\n\nAR = [4, 8, 12, 20, 1e3] # last aspect ratio is essentially infinite\n\nsystem_t = Vector{Any}(undef, length(AR))\nsurface_history_t = Vector{Any}(undef, length(AR))\nproperty_history_t = Vector{Any}(undef, length(AR))\nwake_history_t = Vector{Any}(undef, length(AR))\nCF_t = Vector{Vector{Vector{Float64}}}(undef, length(AR))\nCM_t = Vector{Vector{Vector{Float64}}}(undef, length(AR))\n\n# non-dimensional time (t*Vinf/c)\nt = range(0.0, 10.0, step=1/16)\n\n# chord length\nc = 1\n\n# time step\ndt = [t[i+1]-t[i] for i = 1:length(t)-1]\n\nfor i = 1:length(AR)\n\n    # span length\n    b = AR[i]*c\n\n    # planform area\n    S = b*c\n\n    # geometry\n    xle = [0.0, 0.0]\n    yle = [-b/2, b/2]\n    zle = [0.0, 0.0]\n    chord = [c, c]\n    theta = [0.0, 0.0]\n    phi = [0.0, 0.0]\n    fc = fill((xc) -> 0, 2) # camberline function for each section\n    ns = 13\n    nc = 4\n    spacing_s = Uniform()\n    spacing_c = Uniform()\n    mirror = false\n    symmetric = false\n\n    # reference parameters\n    cref = c\n    bref = b\n    Sref = S\n    rref = [0.0, 0.0, 0.0]\n    Vinf = 1.0 # reference velocity is 1.0\n    ref = Reference(Sref, cref, bref, rref, Vinf)\n\n    # freestream parameters\n    Vinf = 0.0 # freestream velocity is 0.0\n    alpha = 5.0*pi/180\n    beta = 0.0\n    Omega = [0.0; 0.0; 0.0]\n    fs = Freestream(Vinf, alpha, beta, Omega)\n\n    # create vortex rings\n    grid, surface = wing_to_surface_panels(xle, yle, zle, chord, theta, phi, ns, nc;\n        mirror=mirror, fc=fc, spacing_s=spacing_s, spacing_c=spacing_c)\n\n    # create vector containing surfaces at each time step\n    surfaces = [[VortexLattice.translate(surface,\n        -t[it]*[cos(alpha), 0, sin(alpha)])] for it = 1:length(t)]\n\n    # run analysis\n    system_t[i], surface_history_t[i], property_history_t[i], wake_history_t[i] =\n        unsteady_analysis(surfaces, ref, fs, dt; symmetric, wake_finite_core = false)\n\n    # extract forces at each time step\n    CF_t[i], CM_t[i] = body_forces_history(system_t[i], surface_history_t[i],\n        property_history_t[i]; frame=Wind())\n\nend\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As can be seen, the transient lift and drag coefficients for the two setups are identical.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\n\n# lift coefficient plot\nplot(\n    xlim = (0.0, 10.0),\n    xticks = 0.0:1.0:10.0,\n    xlabel = \"\\$ \\\\frac{U_\\\\infty t}{c} \\$\",\n    ylim = (0.0, 0.55),\n    yticks = 0.0:0.1:0.5,\n    ylabel = \"\\$ C_{L} \\$\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nfor i = 1:length(AR)\n    CL = [CF_t[i][j][3] for j = 1:length(CF_t[i])]\n    plot!(t[2:end], CL, label=\"AR = $(AR[i])\")\nend\n\nplot!(show=true)\n\nsavefig(\"moving-rectangular-wing-sudden-acceleration-cl.svg\") # hide\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# drag coefficient plot\nplot(\n    xlim = (0.0, 10.0),\n    xticks = 0.0:1.0:10.0,\n    xlabel = \"\\$ \\\\frac{U_\\\\infty t}{c} \\$\",\n    ylim = (0.0, 0.030),\n    yticks = 0.0:0.005:0.03,\n    ylabel = \"\\$ C_{D} \\$\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nfor i = 1:length(AR)\n    CD = [CF_t[i][j][1] for j = 1:length(CF_t[i])]\n    plot!(t[2:end], CD, label=\"AR = $(AR[i])\")\nend\n\nplot!(show=true)\n\nsavefig(\"moving-rectangular-wing-sudden-acceleration-cd.svg\") # hide\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Visualizing the solution shows the movement of the body in the global reference frame.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"write_vtk(\"acceleration-AR4-moving\", surface_history_t[1], property_history_t[1],\n    wake_history_t[1], dt; symmetric=false)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For infinite aspect ratios, the problem degenerates into the analysis of the sudden acceleration of a 2D flat plate, for which we have an analytical solution through the work of Herbert Wagner.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# See Katz and Plotkin: Figure 13.37\n# AR = ∞\n# Vinf*Δt/c = 1/16\n# α = 5°\n\n# essentially infinite aspect ratio\nAR = 1e3\n\n# chord length\nc = 1\n\n# span length\nb = AR*c\n\n# planform area\nS = b*c\n\n# geometry\nxle = [0.0, 0.0]\nyle = [-b/2, b/2]\nzle = [0.0, 0.0]\nchord = [c, c]\ntheta = [0.0, 0.0]*pi/180\nphi = [0.0, 0.0]\nfc = fill((xc) -> 0, 2) # camberline function for each section\nns = 1\nnc = 4\nspacing_s = Uniform()\nspacing_c = Uniform()\nmirror = false\nsymmetric = false\n\n# reference parameters\ncref = c\nbref = b\nSref = S\nrref = [0.0, 0.0, 0.0]\nVinf = 1.0\nref = Reference(Sref, cref, bref, rref, Vinf)\n\n# freestream parameters\nalpha = 5.0*pi/180\nbeta = 0.0\nOmega = [0.0; 0.0; 0.0]\nfs = Freestream(Vinf, alpha, beta, Omega)\n\n# non-dimensional time (t*Vinf/c)\nt = range(0.0, 7.0, step=1/8)\n\n# time step\ndt = [(t[i+1]-t[i]) for i = 1:length(t)-1]\n\n# create vortex rings\ngrid, surface = wing_to_surface_panels(xle, yle, zle, chord, theta, phi, ns, nc;\n    mirror=mirror, fc=fc, spacing_s=spacing_s, spacing_c=spacing_c)\n\n# create vector containing all surfaces\nsurfaces = [surface]\n\n# run steady analysis\nsystem = steady_analysis(surfaces, ref, fs; symmetric)\n\n# extract steady forces\nCFs, CMs = body_forces(system; frame=Wind())\n\n# run transient analysis\nsystem, surface_history, property_history, wake_history = unsteady_analysis(\n    surfaces, ref, fs, dt; symmetric=symmetric)\n\n# extract transient forces\nCF, CM = body_forces_history(system, surface_history, property_history; frame=Wind())\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The results from VortexLattice compare very well with the analytical solution provided by Wagner.  As discussed in Low Speed Aerodynamics by Katz and Plotkin, the difference between the curves can be attributed to the finite acceleration rate during the first time step, which increases the lift sharply during the acceleration and then increases it moderately later.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\n# lift coefficient plot\nplot(\n    xlim = (0.0, 7.0),\n    xticks = 0.0:1.0:7.0,\n    xlabel = \"\\$ \\\\frac{U_\\\\infty t}{c} \\$\",\n    ylim = (0.0, 1.0),\n    yticks = 0.0:0.1:1.0,\n    ylabel = \"\\$ C_{L} \\$\",\n    grid = false,\n    overwrite_figure=false\n    )\n\n# Computational Results\nCL = getindex.(CF, 3)\nCLs = getindex(CFs, 3)\nplot!(t[2:end], CL./CLs, label=\"VortexLattice\")\n\n# Wagner's Function (using approximation of R. T. Jones)\nΦ(t) = 1 - 0.165*exp(-0.045*t) - 0.335*exp(-0.3*t)\n\nplot!(t, Φ.(2*t), label = \"Wagner's Function\")\n\nplot!(show=true)\n\nsavefig(\"rectangular-wing-sudden-acceleration-wagner.svg\") # hide\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Heaving-Oscillations-of-a-Rectangular-Wing","page":"Examples","title":"Heaving Oscillations of a Rectangular Wing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to predict the transient forces and moments for a heaving rectangular wing.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Katz and Plotkin: Figures 13.38a\n# AR = 4\n# k = ω*c/(2*Vinf) = [0.5, 0.3, 0.1]\n# c = [1.0, 0.6, 0.2]\n# α = -5°\n\nusing VortexLattice\n\n# forward velocity\nVinf = 1\n\n# angle of attack\nalpha = -5*pi/180\n\n# aspect ratio\nAR = 4\n\n# chord lengths\nc = [1.0, 0.6, 0.2]\n\n# reduced frequency\nk = [0.5, 0.3, 0.1]\n\nt = Vector{Vector{Float64}}(undef, length(k))\nCF = Vector{Vector{Vector{Float64}}}(undef, length(k))\nCM = Vector{Vector{Vector{Float64}}}(undef, length(k))\n\nfor i = 1:length(k)\n\n    # span length\n    b = AR*c[i]\n\n    # geometry\n    xle = [0.0, 0.0]\n    yle = [0.0, b/2]\n    zle = [0.0, 0.0]\n    chord = [c[i], c[i]]\n    theta = [0.0, 0.0]\n    phi = [0.0, 0.0]\n    fc = fill((xc) -> 0, 2) # camberline function for each section\n    ns = 13\n    nc = 4\n    spacing_s = Uniform()\n    spacing_c = Uniform()\n    mirror = false\n    symmetric = true\n\n    # reference parameters\n    cref = c[i]\n    bref = b\n    Sref = b*c[i]\n    rref = [0.0, 0.0, 0.0]\n    ref = Reference(Sref, cref, bref, rref, Vinf)\n\n    # angular frequency\n    ω = 2*Vinf*k[i]/c[i]\n\n    # time\n    t[i] = range(0.0, 9*pi/ω, length = 100)\n    dt = t[i][2:end] - t[i][1:end-1]\n    dt = Vinf*dt\n\n    # heaving amplitude\n    h = 0.1*c[i]\n\n    # use forward and vertical velocity at beginning of each time step\n    Xdot = Vinf*cos(alpha)\n    Zdot = Vinf*sin(alpha) .- h*cos.(ω*t[i][1:end-1])\n\n    # freestream parameters for each time step\n    fs = trajectory_to_freestream(dt; Xdot, Zdot)\n\n    # surface panels\n    grid, surface = wing_to_surface_panels(xle, yle, zle, chord, theta, phi, ns, nc;\n        mirror=mirror, fc=fc, spacing_s=spacing_s, spacing_c=spacing_c)\n\n    # create vector containing all surfaces\n    surfaces = [surface]\n\n    # run analysis\n    system, surface_history, property_history, wake_history = unsteady_analysis(\n        surfaces, ref, fs, dt; symmetric=symmetric, nwake = 50)\n\n    # extract forces at each time step (uses instantaneous velocity as reference)\n    CF[i], CM[i] = body_forces_history(system, surface_history, property_history; frame=Wind())\n\nend\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Plotting the results reveals that the results are similar to the results in Figure 13.34 of Low-Speed Aerodynamic by Katz and Plotkin, which verifies the unsteady vortex lattice method implementation in VortexLattice.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\n\n# lift coefficient plot\nplot(\n    xlim = (6*pi, 8*pi),\n    xticks = ([6*pi, 13*pi/2, 7*pi, 15*pi/2, 8*pi], [\"\\$ 0 \\$\",\n        \"\\$ \\\\frac{\\\\pi}{2} \\$\", \"\\$ \\\\pi \\$\", \"\\$ \\\\frac{3\\\\pi}{2} \\$\",\n        \"\\$ 2\\\\pi \\$\"]),\n    xlabel = \"\\$ ω \\\\cdot t \\$\",\n    ylim = (-1.0, 0.1),\n    yticks = -1.0:0.2:0.0,\n    yflip = true,\n    ylabel = \"\\$ C_{L} \\$\",\n    grid = false,\n    )\n\nfor i = 1:length(k)\n    # extract ω\n    ω = 2*Vinf*k[i]/c[i]\n\n    # extract ω*t (use time at the beginning of the time step)\n    ωt = ω*t[i][1:end-1]\n\n    # extract CL\n    CL = [CF[i][it][3] for it = 1:length(t[i])-1]\n\n    plot!(ωt, CL, label=\"\\$ k = \\\\frac{\\\\omega c}{2 U_\\\\infty} = $(k[i]) \\$\")\nend\n\nplot!(show=true)\n\nsavefig(\"heaving-rectangular-wing.svg\") # hide\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Visualizing the k=0.5 case in ParaView yields the following animation.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#OpenVSP-Geometry-Import","page":"Examples","title":"OpenVSP Geometry Import","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to import a wing geometry created using OpenVSP into VortexLattice for analysis. We'll make use of the default swept wing inside OpenVSP with a few minor changes.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Start up OpenVSP and create the default wing. Change the airfoil to NACA 2412 sections so that our wing has a camber to it. VortexLattice will make use of the cambersurface computed by OpenVSP when simulating it. The number of spanwise panels was increased to 20 per semispan in this example.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Once the geometry has been created, write out a DegenGeom file by selecting DegenGeom in the Analysis tab in OpenVSP. We only require a DegenGeom file in the csv format. The example DegenGeom file named samplewing.csv provided in docs/src was created in this manner.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The DegenGeom file can be imported into VortexLattice by using the functions read_degengeom and import_vsp. The read_degengeom function reads the DegenGeom file into an array of components suitable for use inside Julia. The import_vsp function imports required components from the array as specified by the user.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the following example code, a steady state analysis is performed on the sample wing imported from OpenVSP and results are visualized in Paraview.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using VortexLattice\n\nSref = 45.0\ncref = 2.5\nbref = 18.0\nrref = [0.625, 0.0, 0.0]\nVinf = 1.0\nref = Reference(Sref, cref, bref, rref, Vinf)\n\nalpha = 1.0*pi/180\nbeta = 0.0\nOmega = [0.0; 0.0; 0.0]\nfs = Freestream(Vinf, alpha, beta, Omega)\n\n# Import components inside Degengeom file into Julia\ncomp = read_degengeom(\"samplewing.csv\")\n\n# Use the first (and only) imported component to create the lifting surface\ngrid, surface = import_vsp(comp[1]; mirror=true)\n\nsymmetric = false\nsurfaces = [surface]\n\nsystem = steady_analysis(surfaces, ref, fs; symmetric=symmetric)\nproperties = get_surface_properties(system)\nwrite_vtk(\"samplewing\", surfaces, properties; symmetric)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"#VortexLattice","page":"Home","title":"VortexLattice","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Comprehensive Julia implementation of the Vortex Lattice Method","category":"page"},{"location":"","page":"Home","title":"Home","text":"Authors: Taylor McDonnell and Andrew Ning","category":"page"},{"location":"","page":"Home","title":"Home","text":"VortexLattice is a comprehensive pure-Julia implementation of the vortex lattice method for both steady and unsteady flow conditions.  It is designed to be fast, accurate (within theoretical limitations), easy to use, and applicable to arbitrary geometries and velocity fields.  Its steady analysis capabilities have been extensively verified against results generated using AVL and its unsteady analysis capabilities have been verified against unsteady vortex lattice method results generated by Katz and Plotkin.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Vortex Ring Panels\nCambered lifting surfaces\nTrailing vortices in user-specified direction\nOptional finite-core model\nConvenient geometry generation\nFrom pre-existing grid\nFrom lifting surface parameters\nSymmetric geometries\nMultiple lifting surfaces\nMultiple discretization schemes\nUniform\nSine\nCosine\nGeneral freestream description\nFreestream flow angles\nAircraft rotation components\nAdditional velocity as a function of location\nFree/Fixed Wakes\nFree wakes through unsteady analysis\nFixed wakes through steady analysis\nMultiple analyses\nSteady analysis\nUnsteady (time-domain) analysis\nNear field forces\nFar field drag\nBody and stability derivatives\nGeometry and wake visualization using WriteVTK\nExtensively verified against computational results.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Enter the package manager by typing ] and then run the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add VortexLattice","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This code has been optimized to be highly performant, primarily by maintaining type stability and minimizing allocations.  It should outperform vortex lattice method codes written in other higher level languages.  However, it does not yet incorporate the fast multipole method to speed up wake computations, so its performance can still be improved.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the documentation","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1] Drela, M. Flight Vehicle Aerodynamics. MIT Press, 2014.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2] Katz, J., and Plotkin A. Low-Speed Aerodynamics. Cambridge University Press, 2001.","category":"page"}]
}
